<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pusik Gifts - Polished</title>
    <!-- Telegram WebApp SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- TON Connect SDK -->
    <script src="https://unpkg.com/@tonconnect/sdk@latest/dist/tonconnect-sdk.min.js"></script> 
    <!-- TON Connect UI (Ð·Ð°Ð²Ð¸ÑÐ¸Ñ‚ Ð¾Ñ‚ SDK) -->
    <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>
    <!-- Lottie-Web Player from CDN (optional) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>

    <style>
        :root {
            --bg-gradient-start: #181A25; /* Slightly darker base */
            --bg-gradient-mid: #202333;  
            --bg-gradient-end: #12141D;   
            --surface-color: #282B3D; /* Slightly lighter surface */
            --surface-hover-color: #31354A;
            --primary-color: #007AFF; /* Standard Apple Blue */
            --primary-gradient-start: #007AFF;
            --primary-gradient-end: #34AADC; /* Slightly different blue for gradient */  
            --secondary-color: #FF9500; /* Apple Orange */
            --text-primary: #F5F5F7; /* Off-white for less harshness */
            --text-secondary: #AEB4C0; /* Lighter secondary */
            --text-placeholder: #7A7F8F;
            --text-price-color: #C7CDD6; 
            --border-color: rgba(120, 120, 128, 0.25); /* Lighter, more subtle border */
            --border-highlight: var(--primary-color);
            --danger-color: #FF3B30;  /* Apple Red */
            --success-color: #30D158; /* Apple Green */
            --font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --main-border-radius: 16px; /* Slightly more rounded */
            --button-border-radius: 12px;
            --soft-shadow: 0px 6px 20px rgba(0, 0, 0, 0.25);
            --case-grad-default: linear-gradient(145deg, var(--surface-color), var(--surface-hover-color)); 
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            -webkit-overflow-scrolling: touch;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(160deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
            color: var(--text-primary);
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            -webkit-tap-highlight-color: transparent;
            font-weight: 500;
            font-size: 15px;
            line-height: 1.45;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        /* Header */
        #app-header {
            padding: 12px 16px; /* Adjusted padding */
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000;
            background: linear-gradient(to right, rgba(30, 33, 50, 0.88), rgba(40, 43, 60, 0.92)); /* Slightly adjusted alpha */
            backdrop-filter: blur(18px) saturate(180%); /* Increased blur */
            -webkit-backdrop-filter: blur(18px) saturate(180%);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 2px 12px rgba(0,0,0,0.2); /* Refined shadow */
        }
        #app-header .app-title-container {
            display: flex;
            align-items: center;
            gap: 8px; /* Space between logo and title */
        }
        #app-header .app-logo {
            width: 32px; /* Adjust size as needed */
            height: 32px;
            border-radius: 6px; /* Optional: if you want rounded corners for logo */
        }
        #app-header .app-title {
            font-size: 1.5em; /* Slightly larger */
            font-weight: 700; /* Bolder */
            color: var(--text-primary);
            letter-spacing: -0.5px; /* Tighter spacing for modern look */
            flex-shrink: 0; 
            margin-right: 10px;
        }
        #app-header .wallet-info { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            flex-shrink: 1; 
            min-width: 0; 
        }
        #ton-connect-button {
            display: inline-block; 
            flex-shrink: 0; 
        }
        #wallet-address-display, #balance {
            background-color: var(--surface-hover-color); 
            padding: 8px 12px; /* Increased padding */
            border-radius: var(--button-border-radius);
            font-size: 0.875em; 
            font-weight: 600;
            border: 1px solid var(--border-color);
            white-space: nowrap; 
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px; 
            display: none; /* Initially hidden */
            transition: background-color 0.2s;
        }
        #wallet-address-display:hover, #balance:hover {
             background-color: var(--surface-color);
        }
        #wallet-address-display.connected, #balance.connected { 
            display: block; 
        }
        #balance.connected {
            display: flex; /* For alignment if an icon was there */
            align-items: center;
        }
        #ton-connect-button.connected { 
            display: none; 
        }

        /* Content Area */
        #app-content { flex-grow: 1; padding: 24px 18px; overflow-y: auto; padding-bottom: 80px; } /* Increased padding */
        .page { display: none; }
        .page.active { display: block; animation: pageFadeInMinimal 0.3s ease-out; }
        @keyframes pageFadeInMinimal {
            from { opacity: 0; transform: translateY(8px);} 
            to { opacity: 1; transform: translateY(0px);}
        }

        /* Navigation Bar - Updated */
        #app-nav {
            display: flex;
            justify-content: space-around;
            align-items: stretch; /* Make buttons fill height */
            background-color: rgba(28, 28, 30, 0.95); /* More opaque */
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-top: 1px solid var(--border-color);
            padding: 0; /* Remove padding, rely on button padding */
            position: sticky; bottom: 0; z-index: 1000;
            min-height: 65px; /* Increased height */
            box-shadow: 0 -3px 15px rgba(0,0,0,0.15); 
        }
        .nav-button {
            background: none; border: none;
            color: var(--text-secondary);
            display: flex; flex-direction: column; align-items: center; justify-content: center; /* Center content */
            font-size: 11px; 
            font-weight: 500;
            cursor: pointer; padding: 8px 5px; /* Adjusted padding */
            border-radius: 0; /* Remove individual radius for seamless look */
            transition: color 0.2s, background-color 0.2s, transform 0.1s ease-out;
            flex: 1; text-align: center;
            line-height: 1.3; 
        }
        .nav-button:hover { background-color: rgba(255,255,255,0.05); }
        .nav-button:active { transform: scale(0.96); }
        .nav-button.active { 
            color: var(--primary-color); 
            font-weight: 600; 
        }
        .nav-button svg {
            width: 28px; height: 28px; /* Larger icons */
            margin-bottom: 4px; 
            fill: currentColor;
        }
        .nav-button.active svg { fill: var(--primary-color); }


        /* General UI Elements */
        .button {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: var(--text-primary);
            border: none; padding: 14px 24px; /* Adjusted padding */
            border-radius: var(--button-border-radius);
            font-size: 1.0em; /* Standardized font size */
            font-weight: 600;
            cursor: pointer;
            transition: filter 0.2s ease-out, transform 0.15s ease-out, box-shadow 0.2s ease-out;
            text-align: center;
            display: block; 
            width: 100%;
            box-shadow: 0 3px 8px rgba(0,122,255,0.25); /* Refined shadow */
        }
        .button:hover { filter: brightness(1.15); box-shadow: 0 4px 12px rgba(0,122,255,0.3); }
        .button:active { transform: scale(0.97); filter: brightness(0.9); box-shadow: 0 2px 5px rgba(0,122,255,0.2); }
        .button:disabled {
            background: var(--surface-hover-color);
            color: var(--text-placeholder);
            cursor: not-allowed;
            box-shadow: none;
            filter: grayscale(0.5);
        }
        .button-secondary {
            background-color: var(--surface-hover-color); 
            color: var(--text-secondary); 
            border: 1px solid var(--border-color); 
            box-shadow: none;
            background-image: none; 
        }
        .button-secondary:hover { 
            background-color: var(--surface-color); 
            color: var(--text-primary); 
            border-color: rgba(120,120,128,0.5);
        }
        .button-secondary:active {
             background-color: var(--surface-hover-color);
             filter: brightness(0.9);
        }
        .button-secondary:disabled {
            background: var(--surface-color); /* Slightly different disabled for secondary */
            color: var(--text-placeholder);
             border-color: var(--border-color);
            cursor: not-allowed;
            filter: grayscale(0.3);
        }


        h2 {
            margin-top: 0; font-size: 2.0em; /* Slightly larger */
            font-weight: 700;
            color: var(--text-primary);
            padding-bottom: 10px; margin-bottom: 28px; /* Increased margin */
            letter-spacing: -0.5px;
        }
        h3 { 
            font-size: 1.15em; 
            font-weight: 600;
            color: var(--text-secondary);
            margin-top: 24px; /* Increased margin */
            margin-bottom: 14px;
            text-transform: uppercase; 
            letter-spacing: 0.8px; /* Wider spacing */
        }
        .content-card { 
            background-color: var(--surface-color);
            padding: 20px; /* Increased padding */
            border-radius: var(--main-border-radius);
            margin-bottom: 20px;
            border: 1px solid var(--border-color); /* Subtle border for cards */
            box-shadow: 0 2px 8px rgba(0,0,0,0.1); /* Soft shadow for cards */
        }


        /* Main Page - Cases */
        .cases-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(max(150px, calc(50% - 10px - 1px)), 1fr)); 
            gap: 20px; 
        }
        .case-card {
            background-image: var(--case-grad-default);
            border-radius: var(--main-border-radius);
            padding: 20px; 
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.25s ease; 
            border: 1px solid var(--border-color); 
            overflow: hidden; 
            position: relative;
        }

        .case-card:hover {
            filter: brightness(1.12);
            transform: translateY(-6px) scale(1.02); 
            box-shadow: var(--soft-shadow);
        }
        .case-card .case-image-display { 
            width: 85px; height: 85px; 
            margin: 0 auto 18px auto; 
            background-color: transparent; 
            border-radius: var(--button-border-radius);
            overflow: hidden;
            position: relative; 
        }
        .case-card .case-image-display img {
            display: block;
            width: 100%; height: 100%;
            object-fit: cover; 
        }
         .case-card .case-image-display .overlay-image { 
             position: absolute;
             width: 70%; 
             height: 70%;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             object-fit: contain; 
             pointer-events: none; 
             filter: drop-shadow(0 3px 5px rgba(0,0,0,0.35)); 
         }

        .case-card .case-name {
            font-weight: 600;
            font-size: 1.05em; margin-bottom: 8px; 
            color: var(--text-primary); 
            min-height: 2.5em; 
            display: flex; align-items: center; justify-content: center;
        }
        .case-card .case-price {
            font-size: 0.9em; font-weight: 500;
            color: var(--text-price-color);
        }

        /* --- Modal Base --- */
        .modal {
            display: none; position: fixed; z-index: 2000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(10, 10, 20, 0.75); 
            backdrop-filter: blur(12px) saturate(150%); -webkit-backdrop-filter: blur(12px) saturate(150%);
            overflow-y: auto; 
            align-items: flex-start; /* Changed from center to start for better scroll */
            justify-content: center; /* Center horizontally */
            padding-top: 5vh; 
            padding-bottom: 5vh;
        }
        .modal.active { display: flex; animation: modalFadeInMinimal 0.3s ease-out; } 
        .modal-content {
            background-color: var(--surface-color);
            padding: 28px; 
            border-radius: var(--main-border-radius);
            width: 100%; max-width: 420px; 
            text-align: center;
            box-shadow: 0 15px 40px rgba(0,0,0,0.4); 
            border: 1px solid var(--border-color);
            display: flex; flex-direction: column;
            margin: auto; /* This helps with centering when content overflows vertically */
        }
         .modal-content h3 { 
            margin-top: 0; margin-bottom: 20px; 
            font-size: 1.4em; font-weight: 700;
            color: var(--text-primary);
            flex-shrink: 0; 
        }
        .modal-actions { margin-bottom: 18px; display: flex; flex-direction: column; gap: 14px;  flex-shrink: 0; }
        .modal-body { 
            overflow-y: auto; 
            flex-grow: 1; 
            -webkit-overflow-scrolling: touch; 
            margin-top: 12px; 
            max-height: 60vh; /* Limit modal body height if content is too long */
        }


        /* --- Roulette Modal Specifics --- */
        #roulette-wheel-container { width: 100%;  flex-shrink: 0; }
        #roulette-wheel {
            height: 280px; 
            border: 1px solid var(--border-color);
            border-radius: var(--button-border-radius);
            overflow: hidden; position: relative;
            background-color: var(--surface-color); 
            margin: 18px 0 22px 0; 
        }
        #roulette-wheel::before { /* The blue marker line */
            content: '';
            position: absolute;
            left: 10px; right: 10px; top: 50%; /* Centered vertically */
            height: 3px; 
            background-color: var(--primary-color);
            opacity: 0.9; transform: translateY(-50%);
            z-index: 2; pointer-events: none; 
            border-radius: 2px; 
        }
        #roulette-spinner {
            display: flex; flex-direction: column;
            position: absolute; left: 0; width: 100%;
        }
        .roulette-item {
            height: 92px; /* approx 1/3 of roulette-wheel height */
            display: flex; align-items: center; justify-content: center; 
            padding: 0 10px; box-sizing: border-box;
            border-bottom: 1px solid var(--border-color);
            overflow: hidden; 
            transition: opacity 0.3s; 
        }
        .roulette-item:last-child { border-bottom: none; }
        .roulette-item img { 
            max-width: 90%; max-height: 78px; object-fit: contain; 
        }
        .roulette-item.is-winning img { 
             filter: drop-shadow(0 0 8px var(--primary-color)) drop-shadow(0 0 12px var(--primary-gradient-end)); 
        }
        #possible-prizes-display {
            padding-right: 0px; 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); 
            gap: 12px; 
            flex-shrink: 0; 
            margin-top: 12px;
        }
        .prize-card {
            background-color: var(--surface-hover-color);
            border-radius: var(--button-border-radius); padding: 10px; 
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; position: relative; 
            border: 1px solid var(--border-color);
            text-align: center; min-height: 110px; 
        }
        .prize-card-image-placeholder { 
            width: 55px; height: 55px; 
            background-color: transparent;
            border-radius: 8px; margin-bottom: 8px; 
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }
         .prize-card-image-placeholder img {
            display: block; width: 100%; height: 100%; object-fit: contain;
         }
        .prize-card-name {
            font-size: 0.8em; font-weight: 500; color: var(--text-secondary);
            line-height: 1.25; width: 100%; 
            overflow: hidden; text-overflow: ellipsis; 
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
            white-space: normal; 
        }
        .prize-card-probability {
            position: absolute; top: 5px; right: 5px; 
            background-color: var(--primary-color); color: var(--text-primary);
            font-size: 0.7em; font-weight: 600; padding: 2px 5px;
            border-radius: 5px; line-height: 1;
        }
        #prize-display { 
            margin-top: 18px; font-size: 1.25em; font-weight: 600;
            color: var(--success-color);
            flex-shrink: 0;
        }
        #prize-display.hidden { display: none; }
        #roulette-modal hr { 
             border: none; border-top: 1px solid var(--border-color); margin: 18px 0;
              flex-shrink: 0;
         }
         #roulette-modal h4 { 
             font-size: 0.95em; color: var(--text-secondary); margin-bottom: 12px; 
             font-weight: 500;
              flex-shrink: 0;
         }
        /* Style for Black Singularity prize items */
        #possible-prizes-display.black-singularity-style .prize-card-image-placeholder {
            background-color: rgba(10,10,10,0.9); /* Dark grey, almost black */
             border: 1px solid rgba(50,50,50,0.7);
        }
         #possible-prizes-display.black-singularity-style .prize-card {
             background-color: #1A1C2A; /* Slightly darker surface for the card itself */
         }

        
        /* --- Withdraw Modal Specifics --- */
        #withdraw-modal .modal-step { display: none; }
        #withdraw-modal .modal-step.active { display: block; }
        #withdraw-modal p { color: var(--text-secondary); margin-bottom: 18px; line-height: 1.55;}
        #withdraw-modal strong { color: var(--text-primary); font-weight: 600; }
        #withdraw-modal a.button { 
            margin-bottom: 12px; text-decoration: none;
        }
        .loader { 
            border: 4px solid var(--surface-hover-color);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 45px; height: 45px; 
            animation: spin 1s linear infinite;
            margin: 22px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Input fields */
        input[type="text"], input[type="number"], select {
            width: 100%; padding: 13px 15px; 
            margin-bottom: 14px;
            border-radius: var(--button-border-radius);
            background-color: var(--surface-hover-color);
            color: var(--text-primary); border: 1px solid var(--border-color);
            font-size: 1em; font-weight: 500; box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        input[type="text"]::placeholder, input[type="number"]::placeholder { color: var(--text-placeholder); }
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none; border-color: var(--border-highlight);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.25); 
        }

        /* Profile Page Specifics */
        .profile-header { text-align: center; margin-bottom: 28px; padding-top: 12px;}
        .profile-avatar-placeholder {
            width: 88px; height: 88px; border-radius: 50%; 
            background-color: var(--surface-hover-color);
            display: flex; align-items: center; justify-content: center;
            font-size: 2.8em; font-weight: 600; color: var(--text-secondary);
            margin: 0 auto 14px auto; border: 3px solid var(--border-color); 
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        .profile-info .username { font-size: 1.5em; font-weight: 600; margin-bottom: 5px;}
        .profile-info .userid { font-size: 0.9em; color: var(--text-secondary); }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(115px, 1fr)); 
            gap: 12px; 
        }
        .inventory-item {
            background-color: var(--surface-hover-color);
            border-radius: var(--button-border-radius);
            padding: 12px; 
             text-align: center;
             display: flex; 
             flex-direction: column;
             justify-content: space-between; 
             border: 1px solid var(--border-color);
             transition: transform 0.2s, box-shadow 0.2s;
        }
        .inventory-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
        }
         .inventory-item .item-image-display { 
             width: 65px; 
             height: 65px;
             margin: 0 auto 10px auto;
             background-color: transparent;
             border-radius: 8px;
             overflow: hidden;
             display: flex; align-items: center; justify-content: center;
         }
         .inventory-item .item-image-display img {
             display: block; width: 100%; height: 100%; object-fit: contain;
         }
        .inventory-item-name { font-size: 0.88em; font-weight: 500; margin-bottom: 5px; line-height: 1.35; }
        .inventory-item-value { font-size: 0.78em; color: var(--secondary-color); font-weight: 500; margin-bottom: 10px;}
        .inventory-item-actions { display: flex; flex-direction: column; gap: 6px; margin-top: auto; } 
        .inventory-item-actions .button { 
            font-size: 0.78em; padding: 6px 9px; margin: 0; width: 100%; 
        }
         
        #sell-all-button {
            margin-top: 18px;
            background-color: var(--danger-color); 
            color: white;
             background-image: none; 
             box-shadow: 0 3px 8px rgba(255, 59, 48, 0.35);
        }
         #sell-all-button:hover {
              filter: brightness(1.15);
              background-color: var(--danger-color);
              box-shadow: 0 4px 12px rgba(255, 59, 48, 0.4);
         }
         #sell-all-button:active {
             filter: brightness(0.9);
              transform: scale(0.97);
         }
        
        /* Upgrade Page */
         #upgrade-chance-display {
            font-size: 2.8em; font-weight: 700; color: var(--text-primary); 
            text-align:center; margin: 24px auto; padding: 18px; 
            background-color: var(--surface-hover-color);
            border-radius: 50%; width:110px; height:110px; line-height: 74px; 
            border: 4px solid var(--primary-color); 
            box-shadow: 0 0 15px rgba(0,122,255,0.2); 
        }
        .multiplier-buttons { display: flex; justify-content: center; gap: 10px; margin: 24px 0; flex-wrap: wrap; }
        .multiplier-buttons button { width: auto; flex-grow: 1; padding: 11px; font-size: 0.9em;}
        .multiplier-buttons button.active-multiplier {
            background: var(--primary-color); 
            color: var(--text-primary);
            box-shadow: 0 2px 6px rgba(0,122,255,0.3);
        }
        
        /* Invite Page */
         .stats-box { display: flex; justify-content: space-around; margin: 24px 0; gap: 14px; }
        .stat-item {
            background-color: var(--surface-hover-color);
            padding: 14px; border-radius: var(--button-border-radius);
            flex: 1; text-align: center;
            border: 1px solid var(--border-color);
        }
        .stat-item .value { font-size: 1.6em; font-weight: 600; color: var(--primary-color); }
        .stat-item .label { font-size: 0.8em; color: var(--text-secondary); margin-top: 5px; }
        .invited-users-list div { padding: 10px 0; border-bottom: 1px solid var(--border-color); font-size: 0.9em;}
        .invited-users-list div:last-child { border-bottom: none; }

        /* Leaderboard Page */
        .leaderboard-list { 
            padding-left: 0;
            padding-right: 0;
        }
        .leaderboard-list .leader-entry {
            display: flex;
            align-items: center;
            padding: 16px 20px; 
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.25s ease-out; 
            position: relative; 
        }
        .leaderboard-list .leader-entry:hover {
            background-color: rgba(255,255,255,0.04); 
        }
        .leaderboard-list .leader-entry:last-child {
            border-bottom: none;
        }
        .leader-entry .rank {
            font-weight: 700; 
            font-size: 1.05em; 
            min-width: 40px; 
            text-align: left;
            color: var(--text-secondary);
            margin-right: 5px; 
        }
        .leader-entry .avatar-placeholder { 
            width: 44px; 
            height: 44px; 
            border-radius: 50%;
            background-color: var(--surface-hover-color); 
            color: var(--text-secondary);
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: 1.2em; 
            font-weight: 600; 
            margin: 0 16px 0 10px; 
            border: 2px solid var(--border-color); 
        }
        .leader-entry .info {
            flex-grow: 1; 
        }
        .leader-entry .info .name { 
            font-weight: 600; 
            font-size: 1.1em; 
            color: var(--text-primary); 
            margin-bottom: 3px; 
        }
        .leader-entry .info .details { 
            font-size: 0.85em; 
            color: var(--text-secondary); 
            line-height: 1.3;
        }
        .leader-entry .score {
            margin-left: auto; 
            font-weight: 700; 
            font-size: 1.05em; 
            color: var(--primary-color); 
            padding-left: 15px; 
            text-align: right;
        }
         .leader-entry.current-user-entry {
             background-color: rgba(0, 122, 255, 0.12); 
         }
         .leader-entry.current-user-entry .rank {
             color: var(--primary-color); 
         }
         .leader-entry.current-user-entry .info .name {
             color: var(--primary-gradient-end); 
             font-weight: 700; 
        }
        .leader-entry.current-user-entry .score {
            color: var(--secondary-color); 
            font-weight: 800;
        }
        .leader-entry.current-user-entry .avatar-placeholder {
            border-color: var(--primary-color); 
        }


        /* --- Deposit Instructions Modal Styling --- */
        #deposit-instructions-modal .modal-body p {
            color: var(--text-secondary);
            font-size: 0.95em;
            line-height: 1.6;
            margin-bottom: 18px;
        }
        #deposit-instructions-modal .modal-body strong {
            color: var(--text-primary);
            font-weight: 600;
        }
        #deposit-instructions-modal .info-block {
            background-color: var(--surface-hover-color);
            padding: 15px;
            border-radius: var(--button-border-radius);
            margin-bottom: 18px;
            border: 1px solid var(--border-color);
        }
        #deposit-instructions-modal .info-block-title {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        #deposit-instructions-modal .info-block-value {
            font-size: 1.1em;
            font-weight: 500;
            color: var(--text-primary);
            word-break: break-all;
            margin-bottom: 8px;
        }
        #deposit-instructions-modal #ton-transfer-link {
            margin-top: 10px;
            margin-bottom: 20px;
            display: flex; 
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
         #deposit-instructions-modal #ton-transfer-link svg {
            width: 20px; height: 20px; fill: currentColor;
         }
        #deposit-status-message, #deposit-expiry-info {
            text-align: center;
        }
         .promocode-input-group {
             display: flex;
             gap: 10px;
             align-items: center;
             margin-bottom: 10px;
         }
         .promocode-input-group input {
             flex-grow: 1;
             margin-bottom: 0; /* Remove bottom margin from input when in group */
         }
         .promocode-input-group button {
             flex-shrink: 0;
             padding: 13px 18px; /* Match input height */
             width: auto; /* Don't make button full width in group */
         }
    </style>
</head>
<body>
     <div id="app-container">
         <header id="app-header">
            <div class="app-title-container">
                <img src="https://i.ibb.co/N6dt5Pc9/Background-Eraser-20250423-210102862.png" alt="Pusik Gifts Logo" class="app-logo">
                <div class="app-title">Pusik Gifts</div>
            </div>
            <div class="wallet-info">
                <div id="wallet-address-display">Connected: ...</div> 
                <div id="balance">
                    <span id="ton-balance">0.00</span> TON
                </div>
                <div id="ton-connect-button"></div>
            </div>
        </header>

        <main id="app-content">
            <div id="main-page" class="page active">
                <h2>Cases</h2>
                <div id="cases-grid" class="cases-grid">
                    <!-- Cases will be dynamically inserted here -->
                </div>
            </div>

             <div id="upgrade-page" class="page">
                <h2>Upgrade Item</h2> 
                <div class="content-card">
                    <p style="text-align:center; margin-bottom:15px; color: var(--text-secondary);">Select an item from your collection:</p>
                    <select id="upgrade-inventory-select">
                        <option value="">-- Choose Item --</option>
                    </select>
                    <div id="upgrade-chance-display">50%</div> 
                     <p style="text-align:center; margin-bottom:10px; color: var(--text-secondary);">Multiplier:</p>
                    <div id="multiplier-buttons" class="multiplier-buttons">
                        <button class="button button-secondary" data-multiplier="1.5" data-chance="50">x1.5</button>
                        <button class="button button-secondary" data-multiplier="2" data-chance="35">x2</button>
                        <button class="button button-secondary" data-multiplier="3" data-chance="25">x3</button>
                        <button class="button button-secondary" data-multiplier="5" data-chance="15">x5</button>
                        <button class="button button-secondary" data-multiplier="10" data-chance="8">x10</button>
                        <button class="button button-secondary" data-multiplier="20" data-chance="3">x20</button>
                    </div>
                    <button id="do-upgrade-button" class="button">Attempt Upgrade</button>
                    <p id="upgrade-result" style="margin-top: 15px; font-weight: 500; text-align:center;"></p>
                </div>
            </div>

            <div id="invite-page" class="page">
                <h2>Referrals</h2>
                 <div class="content-card">
                    <p style="font-size: 1em; margin-bottom: 15px; text-align:center; color:var(--text-secondary);">Invite friends and earn <strong>10%</strong> of their deposits!</p>
                    <input type="text" id="referral-link" value="Loading..." readonly>
                    <button id="copy-ref-link-button" class="button" style="margin-bottom: 20px;">Copy Referral Code</button>
                    
                    <div class="stats-box" style="margin-bottom: 20px;">
                        <div class="stat-item">
                            <div id="referral-balance" class="value">0.00 TON</div>
                            <div class="label">Referral Earnings</div>
                        </div>
                        <div class="stat-item">
                            <div id="invited-count" class="value">0</div>
                            <div class="label">Friends Invited</div>
                        </div>
                    </div>
                    <button id="withdraw-referral-button" class="button button-secondary">Withdraw Earnings</button>
                </div>
                <div class="content-card">
                    <h3>Invited Friends (Demo)</h3>
                    <div id="invited-users-list-display" class="invited-users-list">
                        <!-- Example, will be populated or show empty message -->
                         <p style="text-align:center; color:var(--text-placeholder);">No friends invited yet.</p> 
                    </div>
                </div>
            </div>


            <div id="leaderboard-page" class="page">
                <h2>Leaderboard</h2>
                <div id="leaderboard-list" class="leaderboard-list content-card" style="padding-top:0; padding-bottom:0;">
                    <!-- Leaderboard entries -->
                </div>
            </div>

            <div id="profile-page" class="page">
                <div class="profile-header">
                    <div id="profile-avatar" class="profile-avatar-placeholder">?</div>
                    <div class="profile-info">
                        <div id="profile-username" class="username">User</div>
                        <div id="profile-userid" class="userid">#...</div>
                    </div>
                </div>

                <div class="content-card">
                    <h3>Balance</h3>
                    <div id="profile-balance-display" style="font-size:1.6em; font-weight:600; margin-bottom:10px;">0.00 TON</div>
                    <input type="number" id="deposit-amount-input" placeholder="Amount in TON (e.g., 1.5)" style="margin-bottom: 10px;">
                    <button id="initiate-deposit-button" class="button">Deposit TON</button>
                </div>
                
                <div class="content-card">
                    <h3>Promocode</h3>
                    <div class="promocode-input-group">
                        <input type="text" id="promocode-input" placeholder="Enter promocode">
                        <button id="redeem-promocode-button" class="button button-secondary">Redeem</button>
                    </div>
                </div>

                <div class="content-card">
                     <h3>Wallet</h3>
                    <div id="profile-wallet-address" style="color:var(--text-secondary); margin-bottom:10px; word-break:break-all;">Not Connected</div>
                    <button id="disconnect-wallet-button" class="button button-secondary" style="display: none;">Disconnect Wallet</button>
                </div>

                <div class="content-card">
                    <h3>My Collection (<span id="inventory-count">0</span>)</h3>
                    <div id="inventory-grid" class="inventory-grid">
                        <p id="empty-inventory-message" style="grid-column: 1 / -1; text-align: center; color: var(--text-placeholder); padding:15px 0;">Your collection is empty.</p>
                        <!-- Inventory items will be here -->
                    </div>
                    <button id="sell-all-button" class="button" style="margin-top: 15px; display: none;">Sell All Items for <span id="sell-all-value">0.00</span> TON</button>
                </div>
            </div>
        </main>

        <nav id="app-nav">
             <button class="nav-button active" data-page="main-page">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                Cases
            </button>
            <button class="nav-button" data-page="upgrade-page">
                 <svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg> <!-- Updated Icon -->
                Upgrade 
            </button>
            <button class="nav-button" data-page="invite-page">
                 <svg viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
                Referrals
            </button>
            <button class="nav-button" data-page="leaderboard-page">
                <svg viewBox="0 0 24 24"><path d="M16,1H4C2.89,1 2,1.89 2,3V17H4V3H16V1M16.5,5H7.5C6.67,5 6,5.67 6,6.5V22.5L12,19.5L18,22.5V6.5C18,5.67 17.33,5 16.5,5M14,11H10V9H14V11M14,15H10V13H14V15Z" /></svg>
                Leaders
            </button>
            <button class="nav-button" data-page="profile-page">
                <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
                Profile
            </button>
        </nav>
    </div>

    <!-- Roulette Modal -->
    <div id="roulette-modal" class="modal">
        <div class="modal-content">
            <h3 id="roulette-case-name">Opening Case...</h3>
            <div id="roulette-wheel-container">
                <div id="roulette-wheel">
                    <div id="roulette-spinner">
                        <!-- Prize images will be dynamically added here -->
                    </div>
                </div>
            </div>
            <div class="modal-actions"> 
                <button id="spin-button" class="button">Spin</button>
                <button id="close-roulette-button" class="button button-secondary">Close</button>
            </div>
            <div id="prize-display" class="hidden"> 
                You got: <span id="won-prize-name"></span>!
            </div>
             <hr>
             <h4>Possible Prizes:</h4>
            <div id="possible-prizes-display">
                 <!-- Possible prize cards will be dynamically inserted here -->
            </div>
        </div>
    </div>

     <!-- Withdraw Modal -->
    <div id="withdraw-modal" class="modal">
        <div class="modal-content">
            <h3>Withdraw Gift</h3>
            <div class="modal-body">
                
                <div id="withdraw-step-1" class="modal-step active">
                    <p>To withdraw your gift via Tonnel Market, you first need to open their Mini App once to register.</p>
                    <a href="https://t.me/tonnel_network_bot/gifts?startapp=ref_5146625949" target="_blank" class="button" style="margin-bottom: 10px;">Open Tonnel Market</a>
                    <button id="withdraw-step1-next" class="button button-secondary">I've opened it</button>
                </div>

                <div id="withdraw-step-2" class="modal-step">
                    <p>Great! Now, please send <strong>any message</strong> to the <a href="https://t.me/giftrelayer" target="_blank" style="color: var(--primary-color)">@giftrelayer</a> bot in Telegram. This allows the system to send the gift to you.</p> {/* Link Updated */}
                    <button id="withdraw-step2-next" class="button button-secondary">I've sent the message</button>
                     <button id="withdraw-step2-back" class="button button-secondary" style="margin-top: 10px;">Back</button>
                </div>

                <div id="withdraw-step-3" class="modal-step">
                     <p>Finalizing withdrawal...</p>
                    <div class="loader"></div>
                    <p id="withdraw-status-message" style="font-size: 0.9em; color: var(--text-secondary);"></p>
                    <button id="withdraw-step3-close" class="button button-secondary" style="margin-top: 15px;">Close</button>
                </div>

            </div>
             <button id="close-withdraw-modal-button" class="button button-secondary" style="margin-top: 15px;">Close Window</button>
        </div>
    </div>

    <!-- Deposit Instructions Modal -->
    <div id="deposit-instructions-modal" class="modal">
        <div class="modal-content">
            <h3>Complete Your TON Deposit</h3>
            <div class="modal-body" style="text-align: left;">
                <p>To complete your deposit, please click the link below to open your TON wallet. The transaction details will be pre-filled.</p>
                
                <a id="ton-transfer-link" href="#" target="_blank" class="button">
                    <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"></path><path d="M12.012 6.5a1.023 1.023 0 00-.73.31l-3.204 3.272c-.203.207-.224.537-.04.763l1.715 2.11c.173.214.49.24.69.057l1.864-1.671a.525.525 0 01.742 0l1.864 1.67a.485.485 0 00.69-.057l1.715-2.11a.544.544 0 00-.04-.763L12.742 6.81a1.023 1.023 0 00-.73-.31zm-.001 1.447a.35.35 0 01.247.102l2.462 2.51-1.192 1.47-1.517-1.36a1.222 1.222 0 00-1.737-.001l-1.517 1.36-1.192-1.47 2.463-2.51a.35.35 0 01.247-.102zM8.5 14h7v1.5h-7z"></path></svg>
                    Open Wallet & Pay
                </a>

                <p id="deposit-expiry-info" style="font-size:0.9em; color:var(--text-secondary); margin-bottom:15px;"></p>
                <p id="deposit-status-message" style="font-weight: 500; text-align:center; margin-bottom:15px;"></p>
                <div id="deposit-loader" class="loader" style="display:none; margin: 10px auto;"></div>

                <button id="confirm-payment-sent-button" class="button button-secondary">I Have Sent The Funds</button>
                <button id="cancel-deposit-button" class="button button-secondary" style="margin-top: 10px;">Cancel</button>
            </div>
        </div>
    </div>

<script>
// --- Constants and Global State ---
const IMAGE_BASE_URL = 'https://raw.githubusercontent.com/Vasiliy-katsyka/case/main/GiftImages/';
const CASE_BG_IMAGE_BASE_URL = 'https://raw.githubusercontent.com/Vasiliy-katsyka/case/main/bgs/';
const API_BASE_URL = 'https://case-v48j.onrender.com'; 
const BOT_USERNAME = 'caseKviBot'; // Point 1: Updated bot username

const currentUser = {
    id: null, 
    username: null,
    first_name: 'User', 
    last_name: null,
    walletAddress: null, 
    walletAddressRaw: null,
    tonBalance: 0.00, 
    starBalance: 0,
    inventory: [], 
    referralCode: null, 
    referralEarningsPending: 0,
    total_won_ton: 0,
    invited_friends_count: 0, // For display on invite page
    // invited_friends_list: [], // If you want to display a list
};

let currentOpenCase = null;
let selectedMultiplier = 1.5;
let itemToWithdraw = null; // Stores the ID of the item being withdrawn

const upgradeChances = { 
    1.5: 50, 2: 35, 3: 25, 5: 15, 10: 8, 20: 3
};

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `generateImageFilename` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
function generateImageFilename(name) {
    if (!name) return 'placeholder.png'; 
    if (name === "Durov's Cap") return "Durov's-Cap.png"; 
    if (name === "Vintage Cigar") return "Vintage-CIgar.png"; 
    if (['Amber', 'Midnight_Blue', 'Onyx_Black', 'Black'].includes(name.replace(/-/g,'_'))) { 
         return name.replace('-','_') + '.png'; 
    }
    return name.replace(/\s+/g, '-').replace(/&/g, 'and').replace(/'/g, "") + '.png'; 
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `casesData` ARRAY HERE (BUT UPDATE 'black' CASE's bgImageFilename) ðŸ”´ðŸ”´ðŸ”´
// Example of how to update 'black' case within your casesData array:
// { 
//    id: 'black', name: 'BLACK Singularity', 
//    isBackgroundCase: true, 
//    bgImageFilename: 'image-1.png', // POINT 5: Updated Background Image
//    overlayPrizeName: 'Neko Helmet', 
//    priceTON: 30, 
//    prizes: [ /* ... your prizes ... */ ]
// },
const casesData = [
    { 
        id: 'lolpop', name: 'Lol Pop Stash', imageFilename: generateImageFilename('Lol Pop'), priceTON: 1.5,
        prizes: [
            { name: 'Plush Pepe', imageFilename: generateImageFilename('Plush Pepe'), floorPrice: 1000, probability: 0.001 },
            { name: 'Neko Helmet', imageFilename: generateImageFilename('Neko Helmet'), floorPrice: 15, probability: 0.005 },
            { name: 'Party Sparkler', imageFilename: generateImageFilename('Party Sparkler'), floorPrice: 2, probability: 0.07 },
            { name: 'Homemade Cake', imageFilename: generateImageFilename('Homemade Cake'), floorPrice: 2, probability: 0.07 },
            { name: 'Cookie Heart', imageFilename: generateImageFilename('Cookie Heart'), floorPrice: 1.8, probability: 0.07 },
            { name: 'Jack-in-the-box', imageFilename: generateImageFilename('Jack-in-the-box'), floorPrice: 2, probability: 0.06 },
            { name: 'Skull Flower', imageFilename: generateImageFilename('Skull Flower'), floorPrice: 3.4, probability: 0.023 },
            { name: 'Lol Pop', imageFilename: generateImageFilename('Lol Pop'), floorPrice: 1.4, probability: 0.25 },
            { name: 'Hynpo Lollipop', imageFilename: generateImageFilename('Hynpo Lollipop'), floorPrice: 1.4, probability: 0.25 },
            { name: 'Desk Calendar', imageFilename: generateImageFilename('Desk Calendar'), floorPrice: 1.4, probability: 0.10 },
            { name: 'B-Day Candle', imageFilename: generateImageFilename('B-Day Candle'), floorPrice: 1.4, probability: 0.10 },
        ]
    },
    { 
        id: 'recordplayer', name: 'Record Player Vault', imageFilename: generateImageFilename('Record Player'), priceTON: 6,
        prizes: [
            { name: 'Plush Pepe', imageFilename: generateImageFilename('Plush Pepe'), floorPrice: 1000, probability: 0.0012 },
            { name: 'Record Player', imageFilename: generateImageFilename('Record Player'), floorPrice: 4, probability: 0.40 },
            { name: 'Lol Pop', imageFilename: generateImageFilename('Lol Pop'), floorPrice: 1.4, probability: 0.10 },
            { name: 'Hynpo Lollipop', imageFilename: generateImageFilename('Hynpo Lollipop'), floorPrice: 1.4, probability: 0.10 },
            { name: 'Party Sparkler', imageFilename: generateImageFilename('Party Sparkler'), floorPrice: 2, probability: 0.10 },
            { name: 'Skull Flower', imageFilename: generateImageFilename('Skull Flower'), floorPrice: 3.4, probability: 0.10 },
            { name: 'Jelly Bunny', imageFilename: generateImageFilename('Jelly Bunny'), floorPrice: 3.6, probability: 0.0988 },
            { name: 'Tama Gadget', imageFilename: generateImageFilename('Tama Gadget'), floorPrice: 4, probability: 0.05 },
            { name: 'Snow Globe', imageFilename: generateImageFilename('Snow Globe'), floorPrice: 4, probability: 0.05 },
        ]
    },
    { 
        id: 'swisswatch', name: 'Swiss Watch Box', imageFilename: generateImageFilename('Swiss Watch'), priceTON: 10,
        prizes: [
            { name: 'Plush Pepe', imageFilename: generateImageFilename('Plush Pepe'), floorPrice: 1000, probability: 0.0015 },
            { name: 'Swiss Watch', imageFilename: generateImageFilename('Swiss Watch'), floorPrice: 18, probability: 0.08 },
            { name: 'Neko Helmet', imageFilename: generateImageFilename('Neko Helmet'), floorPrice: 15, probability: 0.10 },
            { name: 'Eternal Rose', imageFilename: generateImageFilename('Eternal Rose'), floorPrice: 11, probability: 0.05 },
            { name: 'Electric Skull', imageFilename: generateImageFilename('Electric Skull'), floorPrice: 12.6, probability: 0.03 },
            { name: 'Diamond Ring', imageFilename: generateImageFilename('Diamond Ring'), floorPrice: 11.4, probability: 0.0395 },
            { name: 'Record Player', imageFilename: generateImageFilename('Record Player'), floorPrice: 4, probability: 0.20 },
            { name: 'Love Potion', imageFilename: generateImageFilename('Love Potion'), floorPrice: 5.4, probability: 0.20 },
            { name: 'Top Hat', imageFilename: generateImageFilename('Top Hat'), floorPrice: 6, probability: 0.15 },
            { name: 'Voodoo Doll', imageFilename: generateImageFilename('Voodoo Doll'), floorPrice: 8.4, probability: 0.149 },
        ]
    },
    { 
        id: 'perfumebottle', name: 'Perfume Chest', imageFilename: generateImageFilename('Perfume Bottle'), priceTON: 20,
        prizes: [
            { name: 'Plush Pepe', imageFilename: generateImageFilename('Plush Pepe'), floorPrice: 1000, probability: 0.0018 },
            { name: 'Perfume Bottle', imageFilename: generateImageFilename('Perfume Bottle'), floorPrice: 42, probability: 0.08 },
            { name: 'Sharp Tongue', imageFilename: generateImageFilename('Sharp Tongue'), floorPrice: 20, probability: 0.12 },
            { name: 'Loot Bag', imageFilename: generateImageFilename('Loot Bag'), floorPrice: 24, probability: 0.09946 },
            { name: 'Swiss Watch', imageFilename: generateImageFilename('Swiss Watch'), floorPrice: 18, probability: 0.15 },
            { name: 'Neko Helmet', imageFilename: generateImageFilename('Neko Helmet'), floorPrice: 15, probability: 0.15 },
            { name: 'Genie Lamp', imageFilename: generateImageFilename('Genie Lamp'), floorPrice: 19.2, probability: 0.15 },
            { name: 'Kissed Frog', imageFilename: generateImageFilename('Kissed Frog'), floorPrice: 18, probability: 0.10 }, 
            { name: 'Electric Skull', imageFilename: generateImageFilename('Electric Skull'), floorPrice: 12.6, probability: 0.07 },
            { name: 'Diamond Ring', imageFilename: generateImageFilename('Diamond Ring'), floorPrice: 11.4, probability: 0.07874 },
        ]
    },
    { 
        id: 'vintagecigar', name: 'Vintage Cigar Safe', imageFilename: generateImageFilename('Vintage Cigar'), priceTON: 40,
        prizes: [
            { name: 'Plush Pepe', imageFilename: generateImageFilename('Plush Pepe'), floorPrice: 1000, probability: 0.002 },
            { name: 'Perfume Bottle', imageFilename: generateImageFilename('Perfume Bottle'), floorPrice: 42, probability: 0.2994 }, // Adjusted to make space for Pepe but keep total ~1
            { name: 'Vintage Cigar', imageFilename: generateImageFilename('Vintage Cigar'), floorPrice: 26, probability: 0.12 },
            { name: 'Swiss Watch', imageFilename: generateImageFilename('Swiss Watch'), floorPrice: 18, probability: 0.12 },
            { name: 'Neko Helmet', imageFilename: generateImageFilename('Neko Helmet'), floorPrice: 15, probability: 0.10 },
            { name: 'Sharp Tongue', imageFilename: generateImageFilename('Sharp Tongue'), floorPrice: 20, probability: 0.10 },
            { name: 'Genie Lamp', imageFilename: generateImageFilename('Genie Lamp'), floorPrice: 19.2, probability: 0.08 },
            { name: 'Mini Oscar', imageFilename: generateImageFilename('Mini Oscar'), floorPrice: 36, probability: 0.08 },
            { name: 'Scared Cat', imageFilename: generateImageFilename('Scared Cat'), floorPrice: 34, probability: 0.05 },
            { name: 'Toy Bear', imageFilename: generateImageFilename('Toy Bear'), floorPrice: 15, probability: 0.0486 },
        ]
    },
    { 
        id: 'astralshard', name: 'Astral Shard Relic', imageFilename: generateImageFilename('Astral Shard'), priceTON: 100,
        prizes: [
            { name: 'Plush Pepe', imageFilename: generateImageFilename('Plush Pepe'), floorPrice: 1000, probability: 0.0025 },
            { name: 'Durov\'s Cap', imageFilename: generateImageFilename('Durov\'s Cap'), floorPrice: 200, probability: 0.09925 }, // Adjusted
            { name: 'Astral Shard', imageFilename: generateImageFilename('Astral Shard'), floorPrice: 120, probability: 0.10 },
            { name: 'Precious Peach', imageFilename: generateImageFilename('Precious Peach'), floorPrice: 120, probability: 0.10 },
            { name: 'Vintage Cigar', imageFilename: generateImageFilename('Vintage Cigar'), floorPrice: 26, probability: 0.12 },
            { name: 'Perfume Bottle', imageFilename: generateImageFilename('Perfume Bottle'), floorPrice: 42, probability: 0.12 },
            { name: 'Swiss Watch', imageFilename: generateImageFilename('Swiss Watch'), floorPrice: 18, probability: 0.10 },
            { name: 'Neko Helmet', imageFilename: generateImageFilename('Neko Helmet'), floorPrice: 15, probability: 0.08 },
            { name: 'Mini Oscar', imageFilename: generateImageFilename('Mini Oscar'), floorPrice: 36, probability: 0.10 },
            { name: 'Scared Cat', imageFilename: generateImageFilename('Scared Cat'), floorPrice: 34, probability: 0.08 },
            { name: 'Loot Bag', imageFilename: generateImageFilename('Loot Bag'), floorPrice: 24, probability: 0.05 },
            { name: 'Toy Bear', imageFilename: generateImageFilename('Toy Bear'), floorPrice: 15, probability: 0.04825 }, // Adjusted
        ]
    },
    { 
        id: 'plushpepe', name: 'Plush Pepe Hoard', imageFilename: generateImageFilename('Plush Pepe'), priceTON: 200,
        prizes: [
            { name: 'Plush Pepe', imageFilename: generateImageFilename('Plush Pepe'), floorPrice: 1000, probability: 0.15 }, // Higher chance as it's the "Pepe" case
            { name: 'Durov\'s Cap', imageFilename: generateImageFilename('Durov\'s Cap'), floorPrice: 200, probability: 0.25 },
            { name: 'Astral Shard', imageFilename: generateImageFilename('Astral Shard'), floorPrice: 120, probability: 0.60 },
        ]
    },
    { 
        id: 'black', name: 'BLACK Singularity', 
        isBackgroundCase: true, bgImageFilename: 'Black.png', overlayPrizeName: 'Neko Helmet', 
        priceTON: 30, 
        prizes: [ 
            { name: 'Plush Pepe', imageFilename: generateImageFilename('Plush Pepe'), floorPrice: 1000, probability: 0.0022 },
            { name: 'Durov\'s Cap', imageFilename: generateImageFilename('Durov\'s Cap'), floorPrice: 200, probability: 0.04934 }, // Adjusted
            { name: 'Perfume Bottle', imageFilename: generateImageFilename('Perfume Bottle'), floorPrice: 42, probability: 0.10 },
            { name: 'Mini Oscar', imageFilename: generateImageFilename('Mini Oscar'), floorPrice: 36, probability: 0.08 },
            { name: 'Scared Cat', imageFilename: generateImageFilename('Scared Cat'), floorPrice: 34, probability: 0.07 },
            { name: 'Vintage Cigar', imageFilename: generateImageFilename('Vintage Cigar'), floorPrice: 26, probability: 0.08 },
            { name: 'Loot Bag', imageFilename: generateImageFilename('Loot Bag'), floorPrice: 24, probability: 0.08 },
            { name: 'Sharp Tongue', imageFilename: generateImageFilename('Sharp Tongue'), floorPrice: 20, probability: 0.08 },
            { name: 'Genie Lamp', imageFilename: generateImageFilename('Genie Lamp'), floorPrice: 19.2, probability: 0.08 },
            { name: 'Swiss Watch', imageFilename: generateImageFilename('Swiss Watch'), floorPrice: 18, probability: 0.07 },
            { name: 'Neko Helmet', imageFilename: generateImageFilename('Neko Helmet'), floorPrice: 15, probability: 0.07 },
            { name: 'Kissed Frog', imageFilename: generateImageFilename('Kissed Frog'), floorPrice: 18, probability: 0.07 }, 
            { name: 'Electric Skull', imageFilename: generateImageFilename('Electric Skull'), floorPrice: 12.6, probability: 0.05 },
            { name: 'Diamond Ring', imageFilename: generateImageFilename('Diamond Ring'), floorPrice: 11.4, probability: 0.05 },
            { name: 'Toy Bear', imageFilename: generateImageFilename('Toy Bear'), floorPrice: 15, probability: 0.06846 }, // Adjusted
        ]
    },
];


// --- Image Preloader ---
const imageUrlsToPreload = [];
if (Array.isArray(casesData)) {
    casesData.forEach(caseItem => {
        if (caseItem.id === 'black' && caseItem.isBackgroundCase) { // Point 5: Special handling for new bg
            imageUrlsToPreload.push('https://i.ibb.co/JR1nWpdn/image-1.png');
        } else if (caseItem.isBackgroundCase && caseItem.bgImageFilename) {
            imageUrlsToPreload.push(CASE_BG_IMAGE_BASE_URL + caseItem.bgImageFilename);
        } else if (caseItem.imageFilename) {
             imageUrlsToPreload.push(IMAGE_BASE_URL + caseItem.imageFilename);
        }

        if(caseItem.isBackgroundCase && caseItem.overlayPrizeName){
            const overlayFilename = generateImageFilename(caseItem.overlayPrizeName);
             if (overlayFilename && !imageUrlsToPreload.includes(IMAGE_BASE_URL + overlayFilename)) {
                 imageUrlsToPreload.push(IMAGE_BASE_URL + overlayFilename);
            }
        }
        if (caseItem.prizes) {
            caseItem.prizes.forEach(prize => {
                if (prize && prize.imageFilename && !imageUrlsToPreload.includes(IMAGE_BASE_URL + prize.imageFilename)) {
                     imageUrlsToPreload.push(IMAGE_BASE_URL + prize.imageFilename);
                }
            });
        }
    });
}
function preloadImages(urls) { urls.forEach(url => { const img = new Image(); img.src = url; }); }

// --- DOM Elements --- 
const headerElements = { 
    title: document.querySelector('#app-header .app-title'),
    walletInfo: document.querySelector('#app-header .wallet-info'),
    tonConnectButton: document.getElementById('ton-connect-button'),
    walletAddressDisplay: document.getElementById('wallet-address-display'),
    balanceDisplay: document.getElementById('balance'),
    tonBalanceSpan: document.getElementById('ton-balance'),
};
const appNavButtons = document.querySelectorAll('.nav-button');
const pages = document.querySelectorAll('.page');
const casesGrid = document.getElementById('cases-grid');

const rouletteModal = document.getElementById('roulette-modal');
const rouletteCaseName = document.getElementById('roulette-case-name');
const rouletteWheel = document.getElementById('roulette-wheel');
const rouletteSpinner = document.getElementById('roulette-spinner');
const prizeDisplay = document.getElementById('prize-display');
const wonPrizeName = document.getElementById('won-prize-name');
const spinButton = document.getElementById('spin-button');
const closeRouletteButton = document.getElementById('close-roulette-button');
const possiblePrizesDisplay = document.getElementById('possible-prizes-display'); 

const withdrawModal = document.getElementById('withdraw-modal'); 
const withdrawSteps = withdrawModal.querySelectorAll('.modal-step');
const withdrawStep1NextBtn = document.getElementById('withdraw-step1-next');
const withdrawStep2NextBtn = document.getElementById('withdraw-step2-next');
const withdrawStep2BackBtn = document.getElementById('withdraw-step2-back');
const withdrawStep3CloseBtn = document.getElementById('withdraw-step3-close');
const withdrawStatusMessage = document.getElementById('withdraw-status-message');
const closeWithdrawModalButton = document.getElementById('close-withdraw-modal-button');


const profileElements = {
    avatar: document.getElementById('profile-avatar'),
    username: document.getElementById('profile-username'),
    userid: document.getElementById('profile-userid'),
    balanceDisplay: document.getElementById('profile-balance-display'),
    walletAddress: document.getElementById('profile-wallet-address'), 
    inventoryGrid: document.getElementById('inventory-grid'),
    inventoryCount: document.getElementById('inventory-count'),
    emptyInventoryMessage: document.getElementById('empty-inventory-message'),
    disconnectWalletButton: document.getElementById('disconnect-wallet-button'),
    depositAmountInput: document.getElementById('deposit-amount-input'),
    initiateDepositButton: document.getElementById('initiate-deposit-button'),
    sellAllButton: document.getElementById('sell-all-button'), 
    sellAllValueSpan: document.getElementById('sell-all-value'),
    promocodeInput: document.getElementById('promocode-input'), // Point 2
    redeemPromocodeButton: document.getElementById('redeem-promocode-button') // Point 2
};

const upgradeElements = {
    inventorySelect: document.getElementById('upgrade-inventory-select'),
    multiplierButtons: document.getElementById('multiplier-buttons'),
    doUpgradeButton: document.getElementById('do-upgrade-button'),
    upgradeResult: document.getElementById('upgrade-result'),
    chanceDisplay: document.getElementById('upgrade-chance-display') 
};

const inviteElements = {
    referralLink: document.getElementById('referral-link'),
    copyRefLinkButton: document.getElementById('copy-ref-link-button'),
    referralBalance: document.getElementById('referral-balance'),
    invitedCount: document.getElementById('invited-count'),
    withdrawReferralButton: document.getElementById('withdraw-referral-button'),
    invitedUsersListDisplay: document.getElementById('invited-users-list-display')
};

const leaderboardList = document.getElementById('leaderboard-list');

const depositInstructionsModal = document.getElementById('deposit-instructions-modal');
const tonTransferLink = document.getElementById('ton-transfer-link'); 
const confirmPaymentSentButton = document.getElementById('confirm-payment-sent-button');
const cancelDepositButton = document.getElementById('cancel-deposit-button');
const depositExpiryInfo = document.getElementById('deposit-expiry-info');
const depositStatusMessageEl = document.getElementById('deposit-status-message');
const depositLoader = document.getElementById('deposit-loader');

let currentPendingDepositId = null;
let depositExpiryInterval = null;
let depositRecipientAddressRaw = ''; 
let depositCommentText = '';       

// --- TON Connect ---
const manifestUrl = 'https://raw.githubusercontent.com/Vasiliy-katsyka/case/main/tonconnect-manifest.json'; 
const tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
    manifestUrl: manifestUrl,
    buttonRootId: 'ton-connect-button' 
});

// --- Telegram BackButton Handler ---
// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR Telegram BackButton Handler CODE HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
let tgBackButton = null;
const backButtonHandlerStack = [];

function _updateTgBackButton() {
    if (!tgBackButton) return;
    if (backButtonHandlerStack.length > 0) {
        const currentHandler = backButtonHandlerStack[backButtonHandlerStack.length - 1];
        tgBackButton.offClick(); // Remove previous, if any
        tgBackButton.onClick(currentHandler);
        tgBackButton.show();
    } else {
        tgBackButton.hide();
        tgBackButton.offClick(); // Ensure it's cleared
    }
}
function pushTgBackButtonHandler(handler) {
    if (!tgBackButton) return;
    backButtonHandlerStack.push(handler);
    _updateTgBackButton();
}
function popTgBackButtonHandler() {
    if (!tgBackButton) return;
    if (backButtonHandlerStack.length > 0) {
        backButtonHandlerStack.pop();
    }
    _updateTgBackButton();
}
function clearTgBackButtonStack() {
    if (!tgBackButton) return;
    backButtonHandlerStack.length = 0;
    _updateTgBackButton();
}
function navigateBackToMainPage() { navigateToPage('main-page'); }
function closeRouletteModalWithBackButton() { closeRouletteModal(); }
function closeWithdrawModalWithBackButton() { closeWithdrawModal(); }
function closeDepositModalWithBackButton() { closeDepositInstructionsModal(); }


// --- API Helper ---
// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `apiRequest` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
async function apiRequest(endpoint, method = 'GET', body = null) {
    const headers = {
        'Content-Type': 'application/json',
    };
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.initData) {
        headers['X-Telegram-Init-Data'] = Telegram.WebApp.initData;
    } else {
        console.warn("Telegram.WebApp.initData not available for API request.");
        // For dev, you might want to simulate or allow calls without it
        // but for prod, this often means an unauthenticated request.
    }

    const config = {
        method: method, 
        headers: headers,
    };
    if (body && (method.toUpperCase() === 'POST' || method.toUpperCase() === 'PUT')) { 
        config.body = JSON.stringify(body);
    }

    try {
        const response = await fetch(API_BASE_URL + endpoint, config);
        if (!response.ok) {
            let errorData;
            try {
                errorData = await response.json();
            } catch (e) {
                // If response is not JSON, use status text
                errorData = { error: `HTTP error! status: ${response.status}, ${response.statusText}` };
            }
            console.error(`API Error (${endpoint} - ${response.status}):`, errorData);
            showTGNotification(errorData.error || errorData.message || `Request failed: ${response.statusText}`, 'error');
            throw new Error(errorData.error || errorData.message || `HTTP error! status: ${response.status}`);
        }
        if (response.status === 204) { // No Content
            return null;
        }
        return await response.json();
    } catch (error) {
        console.error(`Network or API request error (${endpoint}):`, error);
        // Avoid double-notifying if showTGNotification was already called for HTTP errors
        if (!(error.message.startsWith("HTTP error!") || (error.message.includes("Request failed") && error.message.includes("status")) )) { 
             showTGNotification(`Network error: ${error.message}`, 'error');
        }
        throw error; // Re-throw to be caught by calling function if needed
    }
}


// --- Utility Functions ---
function updateBalances() {
    if (headerElements.tonBalanceSpan) {
        headerElements.tonBalanceSpan.textContent = `${currentUser.tonBalance.toFixed(2)}`; // Removed " TON" as it's outside span
    }
    if (profileElements.balanceDisplay) {
         profileElements.balanceDisplay.innerHTML = `${currentUser.tonBalance.toFixed(2)} TON`;
    }
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `navigateToPage` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
function navigateToPage(pageId) {
    pages.forEach(page => page.classList.remove('active'));
    const targetPage = document.getElementById(pageId);
    if (targetPage) {
        targetPage.classList.add('active');
    }
    appNavButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.page === pageId);
    });

    if (tgBackButton) {
        if (pageId === 'main-page') {
            clearTgBackButtonStack(); 
        } else {
            while(backButtonHandlerStack.length > 0 &&
                  backButtonHandlerStack[backButtonHandlerStack.length - 1] !== navigateBackToMainPage) {
                popTgBackButtonHandler(); 
            }
            if (backButtonHandlerStack.length === 0) {
                pushTgBackButtonHandler(navigateBackToMainPage);
            }
        }
    }
    window.scrollTo(0, 0); 
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `showTGNotification` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
function showTGNotification(message, type = 'info') { 
    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.showAlert) {
        Telegram.WebApp.showAlert(message);
    } else {
        alert(message); // Fallback for browsers
    }
    // Haptic feedback based on type
    if (window.Telegram && Telegram.WebApp.HapticFeedback) {
        if (type === 'success') Telegram.WebApp.HapticFeedback.notificationOccurred('success');
        else if (type === 'error') Telegram.WebApp.HapticFeedback.notificationOccurred('error');
        else if (type === 'warning') Telegram.WebApp.HapticFeedback.notificationOccurred('warning');
        // else Telegram.WebApp.HapticFeedback.impactOccurred('light'); // For general info
    }
}


// --- Rendering Functions ---
function renderHeader() {
     updateBalances(); 
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `updateUIBasedOnWallet` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
function updateUIBasedOnWallet(wallet) {
     const connected = !!wallet; 
     if (connected) {
        const address = wallet.account.address;
        currentUser.walletAddressRaw = address; 
        const userFriendlyAddress = TonConnectSDK.toUserFriendlyAddress(address, wallet.account.chain === TonConnectSDK.CHAIN.TESTNET);
        currentUser.walletAddress = userFriendlyAddress;

        if (headerElements.walletAddressDisplay) {
            headerElements.walletAddressDisplay.textContent = userFriendlyAddress.substring(0, 5) + '...' + userFriendlyAddress.substring(userFriendlyAddress.length - 4);
            headerElements.walletAddressDisplay.classList.add('connected');
            headerElements.walletAddressDisplay.style.display = 'block'; 
        }
        if(headerElements.balanceDisplay) {
             headerElements.balanceDisplay.classList.add('connected');
             headerElements.balanceDisplay.style.display = 'flex'; 
        }
        if(headerElements.tonConnectButton) headerElements.tonConnectButton.style.display = 'none'; 
        
        if(profileElements.walletAddress) profileElements.walletAddress.textContent = userFriendlyAddress;
        if(profileElements.disconnectWalletButton) profileElements.disconnectWalletButton.style.display = 'block';

    } else {
        currentUser.walletAddress = null;
        currentUser.walletAddressRaw = null; 
        if (headerElements.walletAddressDisplay) {
            headerElements.walletAddressDisplay.textContent = ''; 
            headerElements.walletAddressDisplay.classList.remove('connected');
             headerElements.walletAddressDisplay.style.display = 'none'; 
        }
        if(headerElements.balanceDisplay) {
             headerElements.balanceDisplay.classList.remove('connected');
             headerElements.balanceDisplay.style.display = 'none'; 
        }
        if(headerElements.tonConnectButton) headerElements.tonConnectButton.style.display = 'block'; 
        
        if(profileElements.walletAddress) profileElements.walletAddress.textContent = 'Not Connected';
        if(profileElements.disconnectWalletButton) profileElements.disconnectWalletButton.style.display = 'none';
    }
    updateBalances(); 
}


function renderCases() {
    casesGrid.innerHTML = '';
    if (!casesData || casesData.length === 0) {
        casesGrid.innerHTML = "<p>Loading cases...</p>"; 
        return;
    }
    const filteredCases = casesData.filter(caseItem => {
        const removedCaseIds = ['happypepe', 'amber', 'midnightblue', 'onyxblack']; // Keep this if you still want to filter
        return !removedCaseIds.includes(caseItem.id);
    });

    filteredCases.forEach(caseItem => {
        const card = document.createElement('div');
        card.className = 'case-card';
        card.dataset.caseId = caseItem.id; 
        card.onclick = () => openRouletteModal(caseItem);

        const imageContainer = document.createElement('div');
        imageContainer.className = 'case-image-display';
        
        const img = document.createElement('img'); 
        img.loading = 'lazy'; 
        img.alt = caseItem.name;
        img.onerror = (e) => { 
            e.target.style.display='none'; 
            imageContainer.textContent = 'â“'; 
            imageContainer.style.fontSize='2.5em'; 
            imageContainer.style.display='flex';
            imageContainer.style.alignItems='center';
            imageContainer.style.justifyContent='center';
        };

        if (caseItem.id === 'black' && caseItem.isBackgroundCase) { // Point 5: Use new direct URL for black case bg
             img.src = 'https://i.ibb.co/JR1nWpdn/image-1.png';
             img.style.objectFit = 'cover'; 
             imageContainer.appendChild(img);
             if(caseItem.overlayPrizeName){ // Keep overlay logic
                 const overlayImg = document.createElement('img');
                 const overlayFilename = generateImageFilename(caseItem.overlayPrizeName);
                 overlayImg.src = overlayFilename ? IMAGE_BASE_URL + overlayFilename : '';
                 overlayImg.alt = caseItem.overlayPrizeName;
                 overlayImg.loading = 'lazy';
                 overlayImg.className = 'overlay-image'; 
                 overlayImg.onerror = (eO) => { eO.target.style.display = 'none'; } 
                 imageContainer.appendChild(overlayImg);
             }
        } else if (caseItem.isBackgroundCase && caseItem.bgImageFilename) {
            img.src = CASE_BG_IMAGE_BASE_URL + caseItem.bgImageFilename;
            img.style.objectFit = 'cover'; 
            imageContainer.appendChild(img);
             if(caseItem.overlayPrizeName){
                 const overlayImg = document.createElement('img');
                 const overlayFilename = generateImageFilename(caseItem.overlayPrizeName);
                 overlayImg.src = overlayFilename ? IMAGE_BASE_URL + overlayFilename : '';
                 overlayImg.alt = caseItem.overlayPrizeName;
                 overlayImg.loading = 'lazy';
                 overlayImg.className = 'overlay-image'; 
                 overlayImg.onerror = (eO) => { eO.target.style.display = 'none'; } 
                 imageContainer.appendChild(overlayImg);
             }
        } else if (caseItem.imageFilename) { 
            img.src = IMAGE_BASE_URL + caseItem.imageFilename;
            img.style.objectFit = 'contain'; 
            imageContainer.appendChild(img);
        } else { 
              imageContainer.textContent = 'ðŸŽ'; 
              imageContainer.style.fontSize='2.5em'; 
              imageContainer.style.display='flex';
              imageContainer.style.alignItems='center';
              imageContainer.style.justifyContent='center';
        }

        const name = document.createElement('div');
        name.className = 'case-name';
        name.textContent = caseItem.name; 

        const price = document.createElement('div');
        price.className = 'case-price';
        let priceText = '';
        if (caseItem.priceTON) priceText += `${caseItem.priceTON.toFixed(1)} TON `;
        if (caseItem.priceStars) priceText += (priceText ? '/ ' : '') + `${caseItem.priceStars} âœ¨`;
        price.textContent = priceText || 'Free';

        card.appendChild(imageContainer);
        card.appendChild(name);
        card.appendChild(price);
        casesGrid.appendChild(card);
    });
}

function renderProfile() {
    profileElements.avatar.textContent = currentUser.first_name ? currentUser.first_name.charAt(0).toUpperCase() : '?';
    profileElements.username.textContent = 
        (currentUser.first_name || currentUser.last_name) 
            ? `${currentUser.first_name || ''} ${currentUser.last_name || ''}`.trim()
            : currentUser.username || 'User';
    profileElements.userid.textContent = currentUser.id ? `#${currentUser.id}` : '#...';
    profileElements.walletAddress.textContent = currentUser.walletAddress || 'Not Connected';
    profileElements.disconnectWalletButton.style.display = currentUser.walletAddress ? 'block' : 'none';
    renderInventory();
}

function renderInventory() {
    profileElements.inventoryGrid.innerHTML = '';
    let totalValue = 0;
    if (currentUser.inventory.length === 0) {
        profileElements.emptyInventoryMessage.style.display = 'block';
        profileElements.sellAllButton.style.display = 'none';
    } else {
        profileElements.emptyInventoryMessage.style.display = 'none';
        currentUser.inventory.forEach(item => {
            totalValue += item.currentValue || item.floorPrice; 
            const itemDiv = document.createElement('div');
            itemDiv.className = 'inventory-item';
            
            const imgContainer = document.createElement('div');
            imgContainer.className = 'item-image-display';
            const img = document.createElement('img');
            img.src = item.imageFilename ? IMAGE_BASE_URL + item.imageFilename : '';
            img.alt = item.name;
            img.loading = 'lazy';
            img.onerror = (e) => { e.target.style.display='none'; imgContainer.textContent = '?';} 
            imgContainer.appendChild(img);

            itemDiv.innerHTML = `
                <div class="inventory-item-name" title="${item.name}">${item.name}</div>
                <div class="inventory-item-value">${(item.currentValue || item.floorPrice).toFixed(2)} TON</div>
                <div class="inventory-item-actions">
                     <button class="button button-secondary withdraw-button" onclick="startWithdrawalProcess(${item.id})">Withdraw</button> 
                    <button class="button button-secondary" onclick="convertToTon(${item.id})">Convert</button>
                </div>
            `;
             itemDiv.insertBefore(imgContainer, itemDiv.firstChild);
            profileElements.inventoryGrid.appendChild(itemDiv);
        });
        profileElements.sellAllButton.style.display = 'block';
        profileElements.sellAllValueSpan.textContent = totalValue.toFixed(2); // This updates the display for "Sell All" button
    }
    profileElements.inventoryCount.textContent = currentUser.inventory.length;
    populateUpgradeInventorySelect();
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `populateUpgradeInventorySelect` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
function populateUpgradeInventorySelect() {
    upgradeElements.inventorySelect.innerHTML = '<option value="">-- Choose Item --</option>';
    currentUser.inventory.forEach(item => {
        const option = document.createElement('option');
        option.value = item.id; // Assuming item.id is the unique inventory item ID
        option.textContent = `${item.name} (${(item.currentValue || item.floorPrice).toFixed(2)} TON)`;
        upgradeElements.inventorySelect.appendChild(option);
    });
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `renderLeaderboard` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
async function renderLeaderboard() {
    leaderboardList.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">Loading leaders...</p>'; 
    try {
        const leaders = await apiRequest('/api/get_leaderboard'); 
        leaderboardList.innerHTML = ''; 
        if (leaders && leaders.length > 0) {
            leaders.forEach(leader => {
                const entry = document.createElement('div');
                entry.className = 'leader-entry';
                if (leader.user_id === currentUser.id) entry.classList.add('current-user-entry');
                entry.innerHTML = `
                    <div class="rank">#${leader.rank}</div>
                    <div class="avatar-placeholder">${leader.avatarChar}</div>
                    <div class="info">
                        <div class="name">${leader.name}</div>
                        <div class="details">Total Won: ${(leader.income || 0).toFixed(2)} TON</div>
                    </div>
                    <div class="score">${(leader.income || 0).toFixed(1)} TON</div>
                `;
                leaderboardList.appendChild(entry);
            });
        } else {
            leaderboardList.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">No leaders yet.</p>';
        }
    } catch (error) {
        leaderboardList.innerHTML = '<p style="text-align:center; color: var(--danger-color);">Could not load leaderboard.</p>';
    }
}


function renderInvitePage() {
    // Point 1: Use BOT_USERNAME constant
    inviteElements.referralLink.value = currentUser.referralCode ? `https://t.me/${BOT_USERNAME}?start=${currentUser.referralCode}` : 'Loading...';
    inviteElements.referralBalance.innerHTML = `${currentUser.referralEarningsPending.toFixed(2)} TON`;
    inviteElements.invitedCount.textContent = currentUser.invited_friends_count || 0; // Use data from backend if available

    // For invited_friends_list, if you fetch it:
    // if (currentUser.invited_friends_list && currentUser.invited_friends_list.length > 0) {
    //     inviteElements.invitedUsersListDisplay.innerHTML = '';
    //     currentUser.invited_friends_list.forEach(friend => {
    //         const div = document.createElement('div');
    //         div.textContent = `${friend.name} - Profit: ${friend.profit_generated.toFixed(2)} TON`;
    //         inviteElements.invitedUsersListDisplay.appendChild(div);
    //     });
    // } else {
    //    inviteElements.invitedUsersListDisplay.innerHTML = '<p style="text-align:center; color:var(--text-placeholder);">No friends invited yet.</p>';
    // }
}


// --- Roulette Logic ---
function openRouletteModal(caseItem) {
    currentOpenCase = caseItem;
    if (!currentOpenCase || !currentOpenCase.prizes) {
        showTGNotification("Error loading case data.", "error");
        return;
    }

    rouletteCaseName.textContent = caseItem.name; 
    spinButton.textContent = `Spin (${caseItem.priceTON ? caseItem.priceTON.toFixed(1) + ' TON' : ''} ${caseItem.priceStars && caseItem.priceTON ? '/' : ''} ${caseItem.priceStars ? caseItem.priceStars + ' âœ¨' : ''})`;
    spinButton.disabled = false;
    prizeDisplay.classList.add('hidden');
    wonPrizeName.textContent = '';
    rouletteSpinner.innerHTML = ''; 
    rouletteSpinner.style.transition = 'none'; 
    rouletteSpinner.style.top = '0px'; 

    let spinnerItemsContent = [];
    // Populate with more items than visible for smooth scrolling illusion
    for (let i = 0; i < 80; i++) { // Needs ~3x visible items + buffer
        const randomPrize = currentOpenCase.prizes[Math.floor(Math.random() * currentOpenCase.prizes.length)];
        spinnerItemsContent.push({ // Store full prize data for bias calculation
            name: randomPrize.name,
            imageFilename: randomPrize.imageFilename,
            floorPrice: randomPrize.floorPrice
        });
    }
    spinnerItemsContent.forEach(prize => {
        if (!prize || !prize.imageFilename) return; 
        const itemEl = document.createElement('div');
        itemEl.className = 'roulette-item';
        const img = document.createElement('img');
        img.src = IMAGE_BASE_URL + prize.imageFilename;
        img.alt = prize.name || 'Prize';
        img.loading = 'lazy';
        img.onerror = (e) => { e.target.style.display='none'; itemEl.textContent = '?'; itemEl.style.fontSize='2em'; } 
        itemEl.appendChild(img);
        rouletteSpinner.appendChild(itemEl);
    });

    possiblePrizesDisplay.innerHTML = '';
    // Point 5: Add class for Black Singularity case
    if (caseItem.id === 'black') {
        possiblePrizesDisplay.classList.add('black-singularity-style');
    } else {
        possiblePrizesDisplay.classList.remove('black-singularity-style');
    }

    const prizeMap = new Map();
    currentOpenCase.prizes.forEach(p => {
        if(!p || !p.name) return; 
        if (prizeMap.has(p.name)) {
            prizeMap.set(p.name, { 
                ...prizeMap.get(p.name), 
                probability: prizeMap.get(p.name).probability + p.probability 
            });
        } else {
            prizeMap.set(p.name, { ...p }); 
        }
    });

    prizeMap.forEach((prizeData, name) => {
        if (!prizeData || !prizeData.imageFilename) return; 
        const probability = prizeData.probability || 0; 
        const prizeCard = document.createElement('div');
        prizeCard.className = 'prize-card';
        
        const imgContainer = document.createElement('div');
        imgContainer.className = 'prize-card-image-placeholder';
        const img = document.createElement('img');
        img.src = IMAGE_BASE_URL + prizeData.imageFilename;
        img.alt = name;
        img.loading = 'lazy';
        img.onerror = (e) => { e.target.style.display='none'; imgContainer.textContent = '?';} 
        imgContainer.appendChild(img);

        prizeCard.innerHTML = `
            <span class="prize-card-probability">${(probability * 100).toFixed(probability < 0.001 ? 3 : (probability < 0.01 ? 2 : 1) )}%</span> 
            <span class="prize-card-name">${name}</span>
        `; 
        prizeCard.insertBefore(imgContainer, prizeCard.firstChild); 
        possiblePrizesDisplay.appendChild(prizeCard);
    });

    rouletteModal.classList.add('active');
    if (tgBackButton) pushTgBackButtonHandler(closeRouletteModalWithBackButton);
    if (window.Telegram && Telegram.WebApp.HapticFeedback) Telegram.WebApp.HapticFeedback.impactOccurred('light');
}

function closeRouletteModal() {
    if (tgBackButton) popTgBackButtonHandler();
    rouletteModal.classList.remove('active');
    currentOpenCase = null;
}

let spinAnimationTimeout; 

async function spinRoulette() { 
    if (!currentOpenCase) return;
    clearTimeout(spinAnimationTimeout); 

    spinButton.disabled = true;
    spinButton.textContent = 'Spinning...';
    prizeDisplay.classList.add('hidden');

    try {
        const result = await apiRequest('/api/open_case', 'POST', { case_id: currentOpenCase.id });
        
        if (result.status === 'success') {
            const winner = result.won_prize; // This is the actual determined winner
            currentUser.tonBalance = result.new_balance_ton;
            updateBalances(); 

            let spinnerItemsForSpin = []; // Array to hold prize data for the visual spin
            const availablePrizes = currentOpenCase.prizes.filter(p => p && p.imageFilename);
            if (availablePrizes.length === 0) {
                 throw new Error("No available prizes with images in this case.");
            }
            // Populate spinnerItemsForSpin with prize data (including floorPrice)
            for (let i = 0; i < 70; i++) { // Number of items in roulette reel, e.g., 70-100
                const randomPrize = availablePrizes[Math.floor(Math.random() * availablePrizes.length)];
                spinnerItemsForSpin.push({
                    name: randomPrize.name,
                    imageFilename: randomPrize.imageFilename,
                    floorPrice: randomPrize.floorPrice
                });
            }
            // Replace one item with the actual winner, ensuring it's visually in the reel
            const winnerVisualIndex = Math.floor(spinnerItemsForSpin.length * 0.85); // Place winner towards the end
            spinnerItemsForSpin[winnerVisualIndex] = {
                name: winner.name,
                imageFilename: winner.imageFilename,
                floorPrice: winner.floorPrice
            };

            rouletteSpinner.innerHTML = ''; 
            spinnerItemsForSpin.forEach(prizeData => {
                 if (!prizeData || !prizeData.imageFilename) return; 
                 const itemEl = document.createElement('div');
                 itemEl.className = 'roulette-item';
                 const img = document.createElement('img');
                 img.src = IMAGE_BASE_URL + prizeData.imageFilename;
                 img.alt = prizeData.name || 'Prize';
                 img.loading = 'lazy';
                 img.onerror = (e) => { e.target.style.display='none'; itemEl.textContent = '?'; itemEl.style.fontSize='2em'; } 
                 itemEl.appendChild(img);
                 rouletteSpinner.appendChild(itemEl);
             });

            const allItemsInSpinner = rouletteSpinner.querySelectorAll('.roulette-item');
            if (allItemsInSpinner.length === 0) { throw new Error("Spinner items not rendered"); }

            const itemHeight = allItemsInSpinner[0].offsetHeight; 
            const rouletteWheelVisibleHeight = rouletteWheel.clientHeight; 

            // Point 6: Roulette Line Stop Visual Bias Logic
            const winningItemData = spinnerItemsForSpin[winnerVisualIndex];
            const itemAboveData = winnerVisualIndex > 0 ? spinnerItemsForSpin[winnerVisualIndex - 1] : null;
            const itemBelowData = winnerVisualIndex < spinnerItemsForSpin.length - 1 ? spinnerItemsForSpin[winnerVisualIndex + 1] : null;

            let visualBiasOffsetPx = 0; // This is the pixel shift of the winning item from true center of the line
            const BIAS_PERCENTAGE = 0.25; // e.g., shift by 25% of item height towards expensive neighbor

            if (itemAboveData && itemAboveData.floorPrice > winningItemData.floorPrice * 1.5) { 
                visualBiasOffsetPx = itemHeight * BIAS_PERCENTAGE; // Shift winner visually DOWN (marker looks higher on it)
            } else if (itemBelowData && itemBelowData.floorPrice > winningItemData.floorPrice * 1.5) {
                visualBiasOffsetPx = -itemHeight * BIAS_PERCENTAGE; // Shift winner visually UP (marker looks lower on it)
            }
            
            // Calculate the scroll distance needed to center the *visually adjusted* position of the winning item
            // 1. Base position to center the winner item:
            let scrollDistanceToCenterWinner = (winnerVisualIndex * itemHeight) + (itemHeight / 2) - (rouletteWheelVisibleHeight / 2);
            // 2. Apply visual bias: If visualBiasOffsetPx is positive, winner moves down, so spinner scrolls UP less.
            let finalScrollDistance = scrollDistanceToCenterWinner - visualBiasOffsetPx;
            // 3. Add a smaller random jitter so it's not always perfectly biased
            const smallerRandomJitter = (Math.random() - 0.5) * (itemHeight * 0.10); // Reduced random jitter
            finalScrollDistance += smallerRandomJitter;


            rouletteSpinner.style.transition = 'none'; 
            rouletteSpinner.style.top = '0px';
            void rouletteSpinner.offsetWidth; // Force reflow

            rouletteSpinner.style.transition = 'top 6s cubic-bezier(0.25, 0.1, 0.2, 1)'; 
            rouletteSpinner.style.top = `-${finalScrollDistance}px`;
            
            if (window.Telegram && Telegram.WebApp.HapticFeedback) Telegram.WebApp.HapticFeedback.impactOccurred('heavy');

            spinAnimationTimeout = setTimeout(() => {
                wonPrizeName.textContent = winner.name; 
                prizeDisplay.classList.remove('hidden');
                spinButton.disabled = false; 
                spinButton.textContent = 'Spin Again'; 
                
                const newItemForInventory = { 
                     id: result.won_prize.id, // Use the actual ID from backend
                     name: winner.name, 
                     imageFilename: winner.imageFilename, 
                     floorPrice: winner.floorPrice, 
                     currentValue: result.won_prize.currentValue, 
                     upgradeMultiplier: 1.0, 
                     obtained_at: Date.now() / 1000 
                };
                currentUser.inventory.push(newItemForInventory);
                renderInventory(); 
                showTGNotification(`You got: ${winner.name}!`, 'success'); 
                
                // Highlight the actual winning item in the spinner (closest to the line after anim)
                 const finalSpinnerTopValue = parseFloat(rouletteSpinner.style.top) || 0;
                 const centerLineY = Math.abs(finalSpinnerTopValue) + rouletteWheelVisibleHeight / 2;
                 let closestItemIndex = 0;
                 let minDistance = Infinity;

                 allItemsInSpinner.forEach((item, index) => {
                     const itemCenterY = (index * itemHeight) + (itemHeight / 2);
                     const distance = Math.abs(itemCenterY - centerLineY);
                     if (distance < minDistance) {
                         minDistance = distance;
                         closestItemIndex = index;
                     }
                 });

                 if (allItemsInSpinner[closestItemIndex]) {
                      allItemsInSpinner.forEach(el => el.classList.remove('is-winning'));
                      allItemsInSpinner[closestItemIndex].classList.add('is-winning');
                 }
            }, 6100); 
        } else {
            showTGNotification(result.error || result.message || 'Failed to open case.', 'error');
            spinButton.disabled = false;
            spinButton.textContent = 'Spin';
        }
    } catch (error) {
        console.error("Error in spinRoulette:", error);
        // showTGNotification is likely called by apiRequest already
        spinButton.disabled = false;
        spinButton.textContent = 'Spin';
    }
}


// --- Other Page Logic --- 
// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `convertToTon` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
async function convertToTon(inventoryItemId) { 
    if (!inventoryItemId) return;
    try {
        const result = await apiRequest('/api/convert_to_ton', 'POST', { inventory_item_id: parseInt(inventoryItemId) });
        if (result.status === 'success') {
            currentUser.tonBalance = result.new_balance_ton;
            currentUser.inventory = currentUser.inventory.filter(item => item.id !== parseInt(inventoryItemId));
            updateBalances();
            renderInventory();
            showTGNotification(result.message, 'success');
        } else {
            showTGNotification(result.error || result.message || 'Conversion failed.', 'error');
        }
    } catch (error) { /* Handled in apiRequest */ }
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `handleUpgrade` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
async function handleUpgrade() { 
    const selectedItemId = upgradeElements.inventorySelect.value;
    if (!selectedItemId) {
        showTGNotification("Please select an item to upgrade.", 'warning'); return;
    }

    upgradeElements.upgradeResult.textContent = "Attempting upgrade...";
    upgradeElements.doUpgradeButton.disabled = true;

    try {
        const result = await apiRequest('/api/upgrade_item', 'POST', {
            inventory_item_id: parseInt(selectedItemId), 
            multiplier_str: selectedMultiplier.toString() 
        });

        if (result.status === 'success') {
            const upgradedItemData = result.item; // Expecting {id, currentValue, name, upgradeMultiplier}
            const itemIndex = currentUser.inventory.findIndex(item => item.id === upgradedItemData.id);
            if (itemIndex !== -1) {
                currentUser.inventory[itemIndex].currentValue = upgradedItemData.currentValue;
                currentUser.inventory[itemIndex].upgradeMultiplier = upgradedItemData.upgradeMultiplier;
                currentUser.inventory[itemIndex].name = upgradedItemData.name; // Name might change if it reflects multiplier
            }
            upgradeElements.upgradeResult.textContent = result.message;
            upgradeElements.upgradeResult.style.color = 'var(--success-color)';
            showTGNotification("Upgrade successful!", 'success');
        } else { // Failed upgrade (item lost or other error)
            if (result.message && (result.message.includes("lost") || result.item_lost === true)) {
                 currentUser.inventory = currentUser.inventory.filter(item => item.id !== parseInt(selectedItemId));
            }
            upgradeElements.upgradeResult.textContent = result.message;
            upgradeElements.upgradeResult.style.color = 'var(--danger-color)';
            showTGNotification(result.message || "Upgrade failed.", 'error');
        }
        renderInventory(); // Re-render inventory and sell-all value
        updateBalances(); // If balance was affected (though not typical for upgrade itself)
        upgradeElements.doUpgradeButton.disabled = false;
        upgradeElements.inventorySelect.value = ''; // Reset select
        upgradeElements.chanceDisplay.textContent = `${upgradeChances[selectedMultiplier]}%`; // Reset chance display
    } catch (error) {
        // apiRequest should handle showing notification
        upgradeElements.upgradeResult.textContent = "Error during upgrade.";
        upgradeElements.upgradeResult.style.color = 'var(--danger-color)';
        upgradeElements.doUpgradeButton.disabled = false;
    }
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `sellAllItems` and `doSellAll` FUNCTIONS HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
async function sellAllItems() {
    if (currentUser.inventory.length === 0) {
        showTGNotification("Your inventory is empty.", "info"); return;
    }
    const totalSellValue = parseFloat(profileElements.sellAllValueSpan.textContent); // Get current displayed value

    if (window.Telegram && Telegram.WebApp.showConfirm) {
        Telegram.WebApp.showConfirm(`Sell all ${currentUser.inventory.length} items for approximately ${totalSellValue.toFixed(2)} TON? This action cannot be undone.`, async (confirmed) => {
            if (confirmed) await doSellAll();
        });
    } else if (confirm(`Sell all ${currentUser.inventory.length} items for approximately ${totalSellValue.toFixed(2)} TON? This action cannot be undone.`)) {
        await doSellAll();
    }
}
async function doSellAll() {
     try {
        // The backend will calculate the sum based on its current DB state of the inventory.
        const result = await apiRequest('/api/sell_all_items', 'POST');
        if (result.status === 'success') {
            currentUser.tonBalance = result.new_balance_ton;
            currentUser.inventory = []; // Clear client-side inventory
            updateBalances();
            renderInventory(); // This will update the "Sell All" button display (hide it, reset value)
            showTGNotification(result.message, "success");
        } else {
            showTGNotification(result.message || "Failed to sell items.", "error");
        }
    } catch (error) { /* Handled in apiRequest */ }
}


// --- Withdraw Flow Logic ---
function showWithdrawStep(stepNumber) {
    withdrawSteps.forEach((step, index) => {
        step.classList.toggle('active', index + 1 === stepNumber);
    });
}

function startWithdrawalProcess(itemId) { // itemId is inventory_item.id
    const item = currentUser.inventory.find(i => i.id === parseInt(itemId));  
    if (!item) {
        showTGNotification("Item not found for withdrawal.", "error"); return;
    }
    itemToWithdraw = item.id; // Store the inventory item's unique ID
    withdrawModal.querySelector('h3').textContent = `Withdraw ${item.name}`; 
    showWithdrawStep(1);
    withdrawModal.classList.add('active');
    if (tgBackButton) pushTgBackButtonHandler(closeWithdrawModalWithBackButton);
}

async function completeWithdrawal() { 
    if (!itemToWithdraw) {
        showTGNotification("No item selected for withdrawal.", "error");
        showWithdrawStep(1); // Go back to selection or close
        return;
    }
    withdrawStatusMessage.textContent = "Processing withdrawal with backend..."; 
    withdrawStatusMessage.style.color = 'var(--text-secondary)'; 
    const loader = withdrawModal.querySelector('.loader'); 
    if(loader) loader.style.display = 'block';
    
    try {
        // Point 3: Call backend to finalize withdrawal and remove item from DB inventory
        const result = await apiRequest(`/api/finalize_withdrawal/${itemToWithdraw}`, 'POST');

        if (result.status === 'success') {
            // Remove item from client-side inventory
            const itemIndex = currentUser.inventory.findIndex(item => item.id === itemToWithdraw);
            let itemName = "Item";
            if (itemIndex !== -1) {
                 itemName = currentUser.inventory[itemIndex].name;
                 currentUser.inventory.splice(itemIndex, 1); 
            }
            renderInventory(); // This is crucial to update "Sell All" value and inventory display
            
            withdrawStatusMessage.textContent = result.message || `${itemName} withdrawal confirmed!`; 
            withdrawStatusMessage.style.color = 'var(--success-color)';
            showTGNotification(result.message || `${itemName} withdrawal confirmed!`, 'success');
        } else {
             withdrawStatusMessage.textContent = result.error || result.message || "Withdrawal failed on backend."; 
             withdrawStatusMessage.style.color = 'var(--danger-color)';
             showTGNotification(result.error || result.message || "Withdrawal failed.", 'error');
        }
    } catch (error) {
        // apiRequest shows notification
        withdrawStatusMessage.textContent = "Error during withdrawal process."; 
        withdrawStatusMessage.style.color = 'var(--danger-color)';
    } finally {
        if(loader) loader.style.display = 'none'; 
        itemToWithdraw = null; // Clear after attempt
    }
}

function closeWithdrawModal() {
    if (tgBackButton) popTgBackButtonHandler();
    withdrawModal.classList.remove('active');
    itemToWithdraw = null;
    showWithdrawStep(1); 
    withdrawModal.querySelector('h3').textContent = "Withdraw Gift"; 
    // Reset status messages if any
    if(withdrawStatusMessage) withdrawStatusMessage.textContent = "";
    const loader = withdrawModal.querySelector('.loader');
    if(loader) loader.style.display = 'none';
}

// --- Deposit Modal Logic ---
// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `initiateDepositProcedure`, `startDepositExpiryTimer`, `verifyPaymentSent`, `closeDepositInstructionsModal` FUNCTIONS HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
async function initiateDepositProcedure() {
    const amountText = profileElements.depositAmountInput.value;
    if (!amountText.trim()) {
        showTGNotification("Please enter an amount to deposit.", 'warning'); return;
    }
    const amount = parseFloat(amountText);
    if (isNaN(amount) || amount <= 0) {
        showTGNotification("Please enter a valid positive amount.", 'error'); return;
    }
    if (amount < 0.1) { 
        showTGNotification("Minimum deposit is 0.1 TON.", 'error'); return;
    }

    profileElements.initiateDepositButton.disabled = true;
    profileElements.initiateDepositButton.textContent = "Initializing...";

    try {
        const result = await apiRequest('/api/initiate_deposit', 'POST', { amount: amount });
        profileElements.initiateDepositButton.disabled = false;
        profileElements.initiateDepositButton.textContent = "Deposit TON";

        if (result.status === 'success') {
            currentPendingDepositId = result.pending_deposit_id;
            depositRecipientAddressRaw = result.recipient_address; 
            depositCommentText = result.comment; 
            
            let finalNanoAmountForLink;
            if (result.final_amount_nano_ton) { 
                finalNanoAmountForLink = result.final_amount_nano_ton;
            } else { // Fallback if backend only sends string display amount
                finalNanoAmountForLink = Math.round(parseFloat(result.amount_to_send) * 1e9);
            }

            const transferUrl = `ton://transfer/${depositRecipientAddressRaw}?amount=${finalNanoAmountForLink}&text=${encodeURIComponent(depositCommentText)}`;
            tonTransferLink.href = transferUrl;
            
            startDepositExpiryTimer(result.expires_at);

            depositStatusMessageEl.textContent = '';
            depositLoader.style.display = 'none';
            confirmPaymentSentButton.disabled = false;
            confirmPaymentSentButton.textContent = 'I Have Sent The Funds';
            depositInstructionsModal.classList.add('active');
            if (tgBackButton) pushTgBackButtonHandler(closeDepositModalWithBackButton);
        } else {
            showTGNotification(result.message || result.error || 'Failed to initiate deposit.', 'error');
        }
    } catch (error) {
        // apiRequest will show error
        profileElements.initiateDepositButton.disabled = false;
        profileElements.initiateDepositButton.textContent = "Deposit TON";
    }
}
function startDepositExpiryTimer(expiresAtISO) {
    if (depositExpiryInterval) clearInterval(depositExpiryInterval);
    const expiryTime = new Date(expiresAtISO).getTime();

    function updateTimer() {
        const now = new Date().getTime();
        const distance = expiryTime - now;

        if (distance < 0) {
            clearInterval(depositExpiryInterval);
            depositExpiryInfo.textContent = "Deposit request has expired.";
            if(confirmPaymentSentButton) confirmPaymentSentButton.disabled = true;
            if(tonTransferLink) tonTransferLink.classList.add('button-secondary'); 
            return;
        }
        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        depositExpiryInfo.textContent = `This request will expire in ${minutes}m ${seconds}s.`;
         if(tonTransferLink) tonTransferLink.classList.remove('button-secondary');
    }
    updateTimer(); 
    depositExpiryInterval = setInterval(updateTimer, 1000);
}
async function verifyPaymentSent() {
    if (!currentPendingDepositId) {
        showTGNotification("No active deposit to verify.", "error");
        return;
    }

    confirmPaymentSentButton.disabled = true;
    confirmPaymentSentButton.textContent = "Verifying...";
    depositLoader.style.display = 'block';
    depositStatusMessageEl.textContent = 'Checking for your transaction... This may take a moment.';

    try {
        const result = await apiRequest('/api/verify_deposit', 'POST', { 
            pending_deposit_id: currentPendingDepositId 
        });

        if (result.status === 'success') {
            showTGNotification(result.message, 'success');
            currentUser.tonBalance = result.new_balance_ton;
            updateBalances(); 
            renderProfile(); 
            closeDepositInstructionsModal(); // This will also pop TG BackButton
        } else if (result.status === 'pending') {
            depositStatusMessageEl.textContent = result.message;
            confirmPaymentSentButton.disabled = false; 
            confirmPaymentSentButton.textContent = "Check Again";
        } else { // Covers 'expired', 'failed', 'error' from backend
            showTGNotification(result.message || "Verification failed.", 'error');
            depositStatusMessageEl.textContent = result.message || "Verification failed.";
            if (result.status === 'expired') {
                 if(tonTransferLink) tonTransferLink.classList.add('button-secondary');
            } else {
                 confirmPaymentSentButton.disabled = false;
                 confirmPaymentSentButton.textContent = "Try Verification Again";
            }
        }
    } catch (error) {
        // apiRequest will show error
        depositStatusMessageEl.textContent = 'An error occurred. Please try again.';
        confirmPaymentSentButton.disabled = false;
        confirmPaymentSentButton.textContent = "Try Verification Again";
    } finally {
        // Hide loader unless still actively checking
        if (depositLoader.style.display === 'block' && (!depositStatusMessageEl.textContent.includes('Please wait') && !depositStatusMessageEl.textContent.includes('Checking'))) {
             depositLoader.style.display = 'none';
        }
    }
}
function closeDepositInstructionsModal() {
    if (tgBackButton) popTgBackButtonHandler();
    depositInstructionsModal.classList.remove('active');
    if (depositExpiryInterval) clearInterval(depositExpiryInterval);
    currentPendingDepositId = null;
    profileElements.depositAmountInput.value = ''; 
    if (tonTransferLink) tonTransferLink.href = '#'; 
    // Reset status messages
    depositStatusMessageEl.textContent = '';
    depositLoader.style.display = 'none';
    depositExpiryInfo.textContent = '';
}


// Point 2: Promocode Redemption
async function redeemPromocode() {
    const code = profileElements.promocodeInput.value.trim();
    if (!code) {
        showTGNotification("Please enter a promocode.", "warning");
        return;
    }
    profileElements.redeemPromocodeButton.disabled = true;
    try {
        const result = await apiRequest('/api/redeem_promocode', 'POST', { promocode_text: code });
        if (result.status === 'success') {
            currentUser.tonBalance = result.new_balance_ton;
            updateBalances();
            showTGNotification(result.message, 'success');
            profileElements.promocodeInput.value = ''; // Clear input on success
        } else {
            showTGNotification(result.message || result.error || "Failed to redeem promocode.", 'error');
        }
    } catch (error) {
        // apiRequest handles notification
    } finally {
        profileElements.redeemPromocodeButton.disabled = false;
    }
}


// --- Event Listeners ---
appNavButtons.forEach(button => { button.addEventListener('click', () => navigateToPage(button.dataset.page)); });
spinButton.addEventListener('click', spinRoulette);
closeRouletteButton.addEventListener('click', closeRouletteModal);

profileElements.disconnectWalletButton.addEventListener('click', () => { tonConnectUI.disconnect(); });
profileElements.initiateDepositButton.addEventListener('click', initiateDepositProcedure);
profileElements.redeemPromocodeButton.addEventListener('click', redeemPromocode); // Point 2


withdrawStep1NextBtn.addEventListener('click', () => showWithdrawStep(2));
withdrawStep2BackBtn.addEventListener('click', () => showWithdrawStep(1));
withdrawStep2NextBtn.addEventListener('click', () => { showWithdrawStep(3); completeWithdrawal(); });
withdrawStep3CloseBtn.addEventListener('click', closeWithdrawModal);
if (closeWithdrawModalButton) closeWithdrawModalButton.addEventListener('click', closeWithdrawModal);


upgradeElements.multiplierButtons.querySelectorAll('button').forEach(button => {
    button.addEventListener('click', (e) => {
        selectedMultiplier = parseFloat(e.target.dataset.multiplier);
        const chance = parseFloat(e.target.dataset.chance);
        upgradeElements.chanceDisplay.textContent = `${chance}%`; 
        upgradeElements.multiplierButtons.querySelectorAll('button').forEach(btn => {
            btn.classList.remove('active-multiplier'); 
            if(!btn.classList.contains('button-secondary')) btn.classList.add('button-secondary');
        });
        e.target.classList.add('active-multiplier');
        if(e.target.classList.contains('button-secondary')) e.target.classList.remove('button-secondary');
    });
});
const defaultMultiplierButton = upgradeElements.multiplierButtons.querySelector(`[data-multiplier="${selectedMultiplier}"]`);
if (defaultMultiplierButton) {
    defaultMultiplierButton.classList.add('active-multiplier');
    if(defaultMultiplierButton.classList.contains('button-secondary')) defaultMultiplierButton.classList.remove('button-secondary');
    upgradeElements.chanceDisplay.textContent = `${defaultMultiplierButton.dataset.chance}%`;
}
upgradeElements.doUpgradeButton.addEventListener('click', handleUpgrade);

inviteElements.copyRefLinkButton.addEventListener('click', () => {
    navigator.clipboard.writeText(inviteElements.referralLink.value)
        .then(() => showTGNotification("Referral Code copied!", 'success'))
        .catch(err => showTGNotification("Failed to copy code.", 'error'));
});
inviteElements.withdrawReferralButton.addEventListener('click', async () => {
    try {
        const result = await apiRequest('/api/withdraw_referral_earnings', 'POST');
        if (result.status === 'success') {
            currentUser.tonBalance = result.new_balance_ton;
            currentUser.referralEarningsPending = result.new_referral_earnings_pending;
            updateBalances();
            renderInvitePage(); 
            showTGNotification(result.message, 'success');
        } else {
            showTGNotification(result.message || result.error || "Failed to withdraw earnings.", 'error');
        }
    } catch (error) { /* Handled in apiRequest */ }
});

if(profileElements.sellAllButton) {
    profileElements.sellAllButton.addEventListener('click', sellAllItems);
}

if(confirmPaymentSentButton) confirmPaymentSentButton.addEventListener('click', verifyPaymentSent);
if(cancelDepositButton) cancelDepositButton.addEventListener('click', closeDepositInstructionsModal);


// --- Initialization ---
async function fetchInitialUserData() {
    if (!Telegram.WebApp.initData) {
        console.warn("No initData, cannot fetch user data from backend.");
        if (!window.Telegram || !window.Telegram.WebApp) { 
            updateUIBasedOnWallet(null); // Handle non-TG environment
            renderHeader(); renderCases(); renderProfile(); renderLeaderboard(); renderInvitePage();
            navigateToPage('main-page');
        } else {
            // In TG env but no initData is unusual, might be an error or early call
            showTGNotification("Error: Telegram data not available. Please restart.", "error");
        }
        return false; // Indicate data fetch failed or was not possible
    }

    console.log("Fetching initial user data from backend...");
    try {
        // Ensure body is an empty object if not sending specific data, but method is POST
        const data = await apiRequest('/api/get_user_data', 'POST', {}); 
        
        currentUser.id = data.id;
        currentUser.username = data.username;
        currentUser.first_name = data.first_name || 'User';
        currentUser.last_name = data.last_name;
        currentUser.tonBalance = data.tonBalance;
        currentUser.starBalance = data.starBalance || 0;
        currentUser.inventory = data.inventory || [];
        currentUser.referralCode = data.referralCode;
        currentUser.referralEarningsPending = data.referralEarningsPending || 0;
        currentUser.total_won_ton = data.total_won_ton || 0;
        currentUser.invited_friends_count = data.invited_friends_count || 0; // For referral page
        // currentUser.invited_friends_list = data.invited_friends_list || []; // If backend sends list

        
        console.log("User data fetched and currentUser updated:", currentUser);
        return true; // Indicate success

    } catch (error) {
        console.error("Failed to fetch initial user data:", error);
        showTGNotification("Could not load your profile data. Please try again later.", 'error');
        return false; // Indicate failure
    }
}

// ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `initializeApp` FUNCTION HERE (UNCHANGED except for log messages if desired) ðŸ”´ðŸ”´ðŸ”´
async function initializeApp() {
    console.log("initializeApp started");
    preloadImages(imageUrlsToPreload); 

    if (window.Telegram && Telegram.WebApp && Telegram.WebApp.BackButton) {
        tgBackButton = Telegram.WebApp.BackButton;
    }

    let initialDataFetched = false;

    // Subscribe to TonConnectUI status changes
    tonConnectUI.onStatusChange(async wallet => { 
        console.log("TON Connect status changed. Wallet:", wallet);
        updateUIBasedOnWallet(wallet); // Update UI based on wallet connection (address, buttons)
        
        // Fetch user data from backend after wallet status change IF initData is available
        // This is useful if the app relies on wallet for some initial user identification not covered by TG initData
        // However, primary user data fetch should be tied to TG initData availability.
        if (!initialDataFetched && window.Telegram && Telegram.WebApp.initData) {
            if (await fetchInitialUserData()) {
                initialDataFetched = true;
                // Full render after data is fetched
                renderHeader(); renderCases(); renderProfile(); renderLeaderboard(); renderInvitePage();
                navigateToPage('main-page'); // Navigate to default page
            }
        }
    });

    // Telegram WebApp specific initializations
    if (window.Telegram && window.Telegram.WebApp) {
        Telegram.WebApp.ready(); 
        Telegram.WebApp.expand(); 
        Telegram.WebApp.enableClosingConfirmation();
        console.log("Telegram WebApp is ready and expanded.");
        
        const tgUser = Telegram.WebApp.initDataUnsafe?.user;
        if (tgUser) {
            console.log("Telegram user data available (unsafe):", tgUser);
            // Potentially pre-fill some currentUser fields if needed before backend call
            // For example, if backend user creation relies on these being present early.
            if (!currentUser.id || currentUser.id !== tgUser.id) { // Check ensures we don't overwrite if already set
                currentUser.id = tgUser.id; 
                currentUser.username = tgUser.username;
                currentUser.first_name = tgUser.first_name || 'User'; // Default if not present
                currentUser.last_name = tgUser.last_name;
                // A simple default referral code based on user ID, backend might override this
                if (!currentUser.referralCode) { 
                    currentUser.referralCode = `ref_${currentUser.id.toString().slice(-6)}`;
                }
            }
        } else {
            console.warn("Telegram.WebApp.initDataUnsafe.user is not available.");
        }
        
        // Set theme colors from CSS variables
        try { 
            const rootStyle = getComputedStyle(document.documentElement);
            let bgColor = rootStyle.getPropertyValue('--bg-gradient-start').trim();
            if (!bgColor || bgColor === "initial" || bgColor === "inherit") { 
                // Fallback if CSS var is not loaded/parsed correctly (should not happen with :root)
                bgColor = '#181A25'; 
            }
            if (bgColor) { // Ensure bgColor is a valid color string
                 Telegram.WebApp.setHeaderColor(bgColor);
                 Telegram.WebApp.setBackgroundColor(bgColor);
                 console.log("Telegram theme colors set to:", bgColor);
            }
        } catch (e) { 
            console.warn("Could not set Telegram WebApp theme colors.", e);
        }

        // Crucial: Fetch user data using initData after TG WebApp is ready
        if (Telegram.WebApp.initData) {
            console.log("initData is available, calling fetchInitialUserData.");
            if (await fetchInitialUserData()) {
                initialDataFetched = true;
            }
        } else { 
            // This case should be rare if app is launched correctly inside Telegram
            console.warn("Running in Telegram WebApp, but initData is NOT available at this point. UI might be incomplete until it loads or connection re-establishes.");
            // Render with defaults or placeholders
            updateUIBasedOnWallet(null); // Assume no wallet connected yet
            renderHeader(); renderCases(); renderProfile(); renderLeaderboard(); renderInvitePage();
            navigateToPage('main-page');
        }

    } else { 
        // Fallback for environments where Telegram SDK is not available (e.g., standard browser)
        console.warn("Telegram WebApp SDK not available. Running in simulated browser mode.");
        // Simulate some currentUser data for testing if needed
        if (!currentUser.referralCode) { 
            currentUser.referralCode = `ref_BROWSER${Math.random().toString(36).substring(2, 8)}`;
        }
        initialDataFetched = true; // Mark as "fetched" for browser mode
        updateUIBasedOnWallet(null); // No wallet in this mode by default
        // Initial render with default/empty data
        renderHeader(); renderCases(); renderProfile(); renderLeaderboard(); renderInvitePage();
        navigateToPage('main-page');
    }

    // Final render pass if data was fetched (covers TG and browser modes if initialDataFetched is true)
    if (initialDataFetched) {
        console.log("Initial data fetched (or simulated), performing final UI render.");
        renderHeader(); 
        renderCases(); 
        renderProfile(); 
        renderLeaderboard(); 
        renderInvitePage();
        navigateToPage('main-page'); // Ensure correct page is active
    } else {
        console.warn("Initial data was NOT successfully fetched. UI might be incomplete or show loading states.");
        // Optionally, display a global loading indicator or an error message if critical data is missing.
    }
     console.log("initializeApp finished.");
}


document.addEventListener('DOMContentLoaded', initializeApp);
    
</script>
</body>
</html>
```

## Backend (Python)

```python
import os
import logging
from flask import Flask, jsonify, request as flask_request
from flask_cors import CORS
import telebot
from telebot import types
from dotenv import load_dotenv
import threading
import time
import random
import re
import hmac
import hashlib
from urllib.parse import unquote, parse_qs, quote 
from datetime import datetime as dt, timezone, timedelta 
import json 

# SQLAlchemy imports
from sqlalchemy import create_engine, Column, Integer, String, Float, ForeignKey, DateTime, Boolean, UniqueConstraint, BigInteger
from sqlalchemy.orm import sessionmaker, relationship, declarative_base
from sqlalchemy.sql import func
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from sqlalchemy import text 

# Pytoniq imports (Ensure it's installed: pip install pytoniq)
from pytoniq import LiteBalancer 
import asyncio


load_dotenv()

BOT_TOKEN = os.environ.get("BOT_TOKEN")
MINI_APP_URL = os.environ.get("MINI_APP_URL", "https://default_mini_app_url.io") 
DATABASE_URL = os.environ.get("DATABASE_URL") 
AUTH_DATE_MAX_AGE_SECONDS = 3600 * 24 # 24 hours for initData validity

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("app.log", encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# --- SQLAlchemy ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° ---
if not DATABASE_URL:
    logger.error("DATABASE_URL Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð² Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ… Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ!")
    exit("DATABASE_URL is not set. Exiting.")

engine = create_engine(DATABASE_URL, pool_recycle=3600, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# --- ÐœÐ¾Ð´ÐµÐ»Ð¸ Ð‘Ð°Ð·Ñ‹ Ð”Ð°Ð½Ð½Ñ‹Ñ… ---
class User(Base):
    __tablename__ = "users"
    id = Column(BigInteger, primary_key=True, index=True, autoincrement=False) 
    username = Column(String, nullable=True, index=True)
    first_name = Column(String, nullable=True)
    last_name = Column(String, nullable=True)
    ton_balance = Column(Float, default=0.0, nullable=False)
    star_balance = Column(Integer, default=0, nullable=False) # Keep if you plan to use stars
    referral_code = Column(String, unique=True, index=True, nullable=True)
    referred_by_id = Column(BigInteger, ForeignKey("users.id"), nullable=True)
    referral_earnings_pending = Column(Float, default=0.0, nullable=False)
    total_won_ton = Column(Float, default=0.0, nullable=False) 
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())
    
    inventory = relationship("InventoryItem", back_populates="owner", cascade="all, delete-orphan")
    pending_deposits = relationship("PendingDeposit", back_populates="owner")
    # For promocode tracking (optional, if one user can activate a code only once)
    # activated_promocodes = relationship("UserPromoCodeActivation", back_populates="user")
    
    # Relationship for referrals made by this user
    referrals_made = relationship("User", backref=relationship("referrer", remote_side=[id]), foreign_keys=[referred_by_id])


class NFT(Base):
    __tablename__ = "nfts"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    name = Column(String, unique=True, index=True, nullable=False)
    image_filename = Column(String, nullable=True) 
    floor_price = Column(Float, default=0.0, nullable=False)
    __table_args__ = (UniqueConstraint('name', name='uq_nft_name'),)

class InventoryItem(Base):
    __tablename__ = "inventory_items"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    user_id = Column(BigInteger, ForeignKey("users.id", ondelete="CASCADE"), nullable=False) 
    nft_id = Column(Integer, ForeignKey("nfts.id"), nullable=False)
    current_value = Column(Float, nullable=False) 
    upgrade_multiplier = Column(Float, default=1.0, nullable=False)
    obtained_at = Column(DateTime(timezone=True), server_default=func.now())
    
    owner = relationship("User", back_populates="inventory")
    nft = relationship("NFT")

class PendingDeposit(Base):
    __tablename__ = "pending_deposits"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    user_id = Column(BigInteger, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    original_amount_ton = Column(Float, nullable=False)
    unique_identifier_nano_ton = Column(BigInteger, nullable=False) # The small random part
    final_amount_nano_ton = Column(BigInteger, nullable=False, index=True) # original_nano + unique_nano
    expected_comment = Column(String, nullable=False, default="cpd7r07ud3s") # Default, can be overridden
    status = Column(String, default="pending", index=True) # pending, completed, expired, failed
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    expires_at = Column(DateTime(timezone=True), nullable=False)
    
    owner = relationship("User", back_populates="pending_deposits")

# Point 2: Promocode Model
class PromoCode(Base):
    __tablename__ = "promo_codes"
    id = Column(Integer, primary_key=True, index=True)
    code_text = Column(String, unique=True, index=True, nullable=False)
    activations_left = Column(Integer, nullable=False, default=0)
    ton_amount = Column(Float, nullable=False, default=0.0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())
    
    # To track who activated which code (optional for more advanced tracking)
    # activations = relationship("UserPromoCodeActivation", back_populates="promocode")

# Optional: For tracking individual user activations of specific promocodes
# class UserPromoCodeActivation(Base):
#     __tablename__ = "user_promo_code_activations"
#     id = Column(Integer, primary_key=True, index=True)
#     user_id = Column(BigInteger, ForeignKey("users.id"), nullable=False)
#     promo_code_id = Column(Integer, ForeignKey("promo_codes.id"), nullable=False)
#     activated_at = Column(DateTime(timezone=True), server_default=func.now())
#     __table_args__ = (UniqueConstraint('user_id', 'promo_code_id', name='uq_user_promocode'),)
#     user = relationship("User", back_populates="activated_promocodes")
#     promocode = relationship("PromoCode", back_populates="activations")


Base.metadata.create_all(bind=engine)


# --- Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð¸Ð¼ÐµÐ½Ð¸ Ñ„Ð°Ð¹Ð»Ð° (Placeholder for your actual function) ---
# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `generate_image_filename_from_name` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
def generate_image_filename_from_name(name_str: str) -> str:
    if not name_str: return 'placeholder.png'
    if name_str == "Durov's Cap": return "Durov's-Cap.png"
    if name_str == "Vintage Cigar": return "Vintage-CIgar.png"
    name_str_replaced_hyphens = name_str.replace('-', '_')
    if name_str_replaced_hyphens in ['Amber', 'Midnight_Blue', 'Onyx_Black', 'Black']:
         return name_str_replaced_hyphens + '.png'
    cleaned_name = name_str.replace('&', 'and')
    cleaned_name = cleaned_name.replace("'", "")
    cleaned_name = re.sub(r'\s+', '-', cleaned_name)
    return cleaned_name + '.png'


# --- Ð”Ð°Ð½Ð½Ñ‹Ðµ ÐºÐµÐ¹ÑÐ¾Ð² (Placeholder for your actual data) ---
# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `cases_data_backend` ARRAY HERE (BUT UPDATE 'black' CASE's bgImageFilename) ðŸ”´ðŸ”´ðŸ”´
# Example of how to update 'black' case:
# { 
#    'id': 'black', 'name': 'BLACK Singularity', 
#    'isBackgroundCase': True, 
#    'bgImageFilename': 'image-1.png', # POINT 5: Updated filename (actual URL is frontend responsibility)
#    'overlayPrizeName': 'Neko Helmet', 
#    'priceTON': 30, 
#    'prizes': [ /* ... your prizes ... */ ]
# },
cases_data_backend = [ # YOUR FULL cases_data_backend ARRAY HERE
    # ...
]


if not cases_data_backend:
    logger.critical("ÐœÐ°ÑÑÐ¸Ð² cases_data_backend ÐŸÐ£Ð¡Ð¢! ÐŸÑ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð½Ðµ ÑÐ¼Ð¾Ð¶ÐµÑ‚ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ. Ð—Ð°Ð¿Ð¾Ð»Ð½Ð¸ ÐµÐ³Ð¾!")

def populate_initial_data():
    if not cases_data_backend:
        logger.error("ÐÐµ Ð¼Ð¾Ð³Ñƒ Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ NFT, Ñ‚Ð°Ðº ÐºÐ°Ðº cases_data_backend Ð¿ÑƒÑÑ‚.")
        return
    db = SessionLocal()
    try:
        # Populate NFTs
        existing_nft_names_query = db.query(NFT.name).all()
        existing_nft_names = {name_tuple[0] for name_tuple in existing_nft_names_query}
        
        nfts_to_add = []
        for case_config in cases_data_backend: 
            for prize in case_config.get('prizes', []):
                if prize['name'] not in existing_nft_names:
                    # image_fn should be derived correctly if not directly provided in prize dict
                    image_fn = prize.get('imageFilename', generate_image_filename_from_name(prize['name']))
                    nfts_to_add.append(NFT(
                        name=prize['name'], image_filename=image_fn, floor_price=prize['floorPrice']
                    ))
                    existing_nft_names.add(prize['name']) # Add to set to avoid duplicates in this batch

        if nfts_to_add:
            db.add_all(nfts_to_add)
            db.commit()
            logger.info(f"Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾ {len(nfts_to_add)} Ð½Ð¾Ð²Ñ‹Ñ… NFT Ð² Ð±Ð°Ð·Ñƒ.")
        else:
            logger.info("ÐÐ¾Ð²Ñ‹Ñ… NFT Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾, Ð¸Ð»Ð¸ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ð° ÑƒÐ¶Ðµ Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð°.")

        # Point 2: Seed "durov" promocode
        durov_code = db.query(PromoCode).filter(PromoCode.code_text == 'durov').first()
        if not durov_code:
            durov_code = PromoCode(code_text='durov', activations_left=10, ton_amount=5.0)
            db.add(durov_code)
            db.commit()
            logger.info("Promocode 'durov' (5 TON, 10 activations) seeded.")
        else:
            logger.info("Promocode 'durov' already exists.")

    except IntegrityError:
        db.rollback()
        logger.warning("ÐžÑˆÐ¸Ð±ÐºÐ° Ñ†ÐµÐ»Ð¾ÑÑ‚Ð½Ð¾ÑÑ‚Ð¸ Ð¿Ñ€Ð¸ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ð¸ NFT/Promocode (Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾, Ð´ÑƒÐ±Ð»Ð¸ÐºÐ°Ñ‚Ñ‹ ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‚). ÐŸÑ€Ð¾Ð¿ÑƒÑÐºÐ°ÐµÐ¼.")
    except Exception as e:
        db.rollback()
        logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ð¸ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹ NFT/Promocode: {type(e).__name__} - {e}")
    finally:
        db.close()

populate_initial_data()

# --- Constants for Deposit ---
DEPOSIT_RECIPIENT_ADDRESS_RAW = "UQBZs1e2h5CwmxQxmAJLGNqEPcQ9iU3BCDj0NSzbwTiGa3hR" # Your actual deposit address
DEPOSIT_COMMENT = "cpd7r07ud3s" # Your desired fixed comment
PENDING_DEPOSIT_EXPIRY_MINUTES = 30 

# --- Flask ÐŸÑ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ---
app = Flask(__name__)
allowed_origins = [
    "https://vasiliy-katsyka.github.io", 
    # "http://127.0.0.1:5500", # For local dev if needed
    # "http://localhost:5500" # For local dev if needed
]
CORS(app, resources={r"/api/*": {"origins": allowed_origins}})

# --- Telegram Ð‘Ð¾Ñ‚ ---
if not BOT_TOKEN: 
    logger.error("Ð¢Ð¾ÐºÐµÐ½ Ð±Ð¾Ñ‚Ð° (BOT_TOKEN) Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½!")
    if __name__ == '__main__': exit("BOT_TOKEN is not set. Exiting.")
    else: raise RuntimeError("BOT_TOKEN is not set. Cannot initialize bot.")
bot = telebot.TeleBot(BOT_TOKEN)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- Ð’Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ Telegram WebApp InitData ---
# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `validate_init_data` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
def validate_init_data(init_data_str: str, bot_token: str) -> dict | None:
    try:
        if not init_data_str:
            logger.warning("initData is empty or None.")
            return None
        
        # URL decode the entire string first
        # init_data_str_decoded = unquote(init_data_str) # Sometimes needed if the whole string is urlencoded
        # parsed_data = dict(parse_qs(init_data_str_decoded))
        parsed_data = dict(parse_qs(init_data_str))


        if 'hash' not in parsed_data or 'user' not in parsed_data or 'auth_date' not in parsed_data:
            logger.warning(f"initData missing required fields. Got: {list(parsed_data.keys())}")
            return None

        hash_received = parsed_data.pop('hash')[0]
        auth_date_ts = int(parsed_data['auth_date'][0])
        current_ts = int(dt.now(timezone.utc).timestamp())

        if (current_ts - auth_date_ts) > AUTH_DATE_MAX_AGE_SECONDS:
            logger.warning(f"initData is outdated. auth_date: {auth_date_ts}, current_ts: {current_ts}, diff: {current_ts - auth_date_ts}s. Max age: {AUTH_DATE_MAX_AGE_SECONDS}s")
            return None 

        data_check_list = []
        # Keys must be sorted alphabetically before forming the data_check_string
        for key in sorted(parsed_data.keys()):
            # Values also need to be unquoted if they were part of the original query string
            # and parse_qs might leave them as lists.
            # value_str = unquote(parsed_data[key][0]) # Ensure value is unquoted if initData comes heavily encoded
            value_str = parsed_data[key][0] # parse_qs already decodes components
            data_check_list.append(f"{key}={value_str}")
        
        data_check_string = "\n".join(data_check_list)

        # HMAC-SHA256 signing
        secret_key_intermediate = bot_token.encode() # Bot token itself
        key_for_secret = "WebAppData".encode() # Constant string "WebAppData"
        secret_key = hmac.new(key_for_secret, secret_key_intermediate, hashlib.sha256).digest()
        
        calculated_hash_bytes = hmac.new(secret_key, data_check_string.encode(), hashlib.sha256)
        calculated_hash_hex = calculated_hash_bytes.hexdigest()

        if calculated_hash_hex == hash_received:
            user_data_json_str = unquote(parsed_data['user'][0]) # User data is a JSON string, URL encoded
            user_info_dict = json.loads(user_data_json_str) 
            # Ensure 'id' is present and is an integer
            if 'id' not in user_info_dict or not isinstance(user_info_dict['id'], (int, float)): # float if from some JS sources
                logger.warning(f"User ID missing or not numeric in parsed user data: {user_info_dict}")
                return None
            
            return {
                "id": int(user_info_dict.get("id")), 
                "first_name": user_info_dict.get("first_name"),
                "last_name": user_info_dict.get("last_name"),
                "username": user_info_dict.get("username"),
                "language_code": user_info_dict.get("language_code"),
                "is_premium": user_info_dict.get("is_premium", False),
                "photo_url": user_info_dict.get("photo_url")
                # Add other fields from user object if needed
            }
        else:
            logger.warning(f"Hash mismatch! Received: {hash_received}, Calculated: {calculated_hash_hex}")
            logger.debug(f"DataCheckString for mismatch: '{data_check_string}'")
            return None
    except Exception as e:
        logger.error(f"Exception during initData validation: {type(e).__name__} - {e}", exc_info=True)
        return None


# --- API Ð­Ð½Ð´Ð¿Ð¾Ð¸Ð½Ñ‚Ñ‹ ---
@app.route('/') 
def index_route(): 
    return "Pusik Gifts Flask App is running!"

@app.route('/api/get_user_data', methods=['POST'])
def get_user_data_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Authentication failed"}), 401
    
    user_id = auth_user_data["id"]
    db = next(get_db())
    user = db.query(User).filter(User.id == user_id).first()
    if not user: 
        logger.warning(f"User {user_id} not found via API, should have been created by /start. Creating now for robustness.")
        user = User(
            id=user_id, username=auth_user_data.get("username"),
            first_name=auth_user_data.get("first_name"), last_name=auth_user_data.get("last_name"),
            ton_balance=0.0, star_balance=0, # Default balances
            referral_code=f"ref_{user_id}_{random.randint(1000,9999)}" # Generate a referral code
        )
        db.add(user)
        try:
            db.commit()
            db.refresh(user)
        except IntegrityError: # Catch if referral code somehow clashes (rare) or other integrity issues
            db.rollback()
            user = db.query(User).filter(User.id == user_id).first() # Try to fetch again if created by race condition
            if not user:
                logger.error(f"Failed to create or fetch user {user_id} after IntegrityError.")
                return jsonify({"error": "Failed to initialize user data"}), 500
        except Exception as e_commit:
            db.rollback()
            logger.error(f"Error creating user {user_id} via API: {e_commit}")
            return jsonify({"error": "Failed to initialize user data"}), 500

    inventory_data = []
    for item in user.inventory: # Ensure inventory items are loaded with their NFT details
        inventory_data.append({
            "id": item.id, "name": item.nft.name, "imageFilename": item.nft.image_filename,
            "floorPrice": item.nft.floor_price, "currentValue": item.current_value,
            "upgradeMultiplier": item.upgrade_multiplier,
            "obtained_at": item.obtained_at.isoformat() if item.obtained_at else None
        })
    
    # Point 1: Get count of invited friends
    invited_friends_count = db.query(User).filter(User.referred_by_id == user_id).count()
    
    return jsonify({
        "id": user.id, "username": user.username, "first_name": user.first_name,
        "last_name": user.last_name, "tonBalance": user.ton_balance,
        "starBalance": user.star_balance, "inventory": inventory_data,
        "referralCode": user.referral_code,
        "referralEarningsPending": user.referral_earnings_pending,
        "total_won_ton": user.total_won_ton,
        "invited_friends_count": invited_friends_count # Point 1
    })

# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `open_case_api` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
@app.route('/api/open_case', methods=['POST'])
def open_case_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Auth failed"}), 401
    user_id = auth_user_data["id"]

    data = flask_request.get_json()
    case_id = data.get('case_id')
    if not case_id: return jsonify({"error": "case_id is required"}), 400

    db = next(get_db())
    user = db.query(User).filter(User.id == user_id).first()
    if not user: return jsonify({"error": "User not found"}), 404

    if not cases_data_backend: return jsonify({"error": "Case data not loaded on backend"}), 500
    target_case = next((c for c in cases_data_backend if c['id'] == case_id), None)
    if not target_case: return jsonify({"error": "Case not found"}), 404

    case_cost_ton = target_case.get('priceTON', 0)
    # case_cost_stars = target_case.get('priceStars', 0) # If you implement star payments

    if user.ton_balance < case_cost_ton:
        return jsonify({"error": f"Not enough TON. Need {case_cost_ton}, have {user.ton_balance:.2f}"}), 400
    # if user.star_balance < case_cost_stars:
    #     return jsonify({"error": "Not enough stars"}), 400
    
    prizes = target_case.get('prizes', [])
    if not prizes: return jsonify({"error": "No prizes in this case"}), 500

    # Determine winner based on probabilities
    total_probability = sum(p.get('probability', 0) for p in prizes)
    winner_data = None

    if total_probability == 0 and prizes: # If no probabilities, pick one at random (equal chance)
        winner_data = random.choice(prizes)
    elif total_probability > 0:
        normalized_prizes = []
        # Normalize probabilities if they don't sum to 1 (or close to it)
        if abs(total_probability - 1.0) > 0.0001: 
            logger.warning(f"Probabilities for case {case_id} do not sum to 1 (sum={total_probability}). Normalizing.")
            for p_info in prizes:
                normalized_prizes.append({**p_info, 'probability': p_info.get('probability',0) / total_probability})
        else:
            normalized_prizes = prizes
        
        rand_val = random.random() # 0.0 to < 1.0
        current_prob_sum = 0
        for prize_info in normalized_prizes:
            current_prob_sum += prize_info.get('probability', 0)
            if rand_val <= current_prob_sum:
                winner_data = prize_info
                break
        if not winner_data: # Fallback if float precision issues, pick last or random from normalized
            winner_data = random.choice(normalized_prizes) 
    else: # No prizes or all probabilities are zero
        return jsonify({"error": "Case prize configuration error"}), 500
    
    if not winner_data: return jsonify({"error": "Could not determine prize"}), 500

    # Deduct cost and add prize to inventory
    user.ton_balance -= case_cost_ton
    # user.star_balance -= case_cost_stars
    user.total_won_ton += winner_data['floorPrice'] # Add prize value to total won

    db_nft = db.query(NFT).filter(NFT.name == winner_data['name']).first()
    if not db_nft:
        # This should ideally not happen if populate_initial_nfts_from_cases ran correctly
        logger.error(f"NFT '{winner_data['name']}' NOT FOUND in DB. This is unexpected. Creating on-the-fly.")
        image_fn_winner = winner_data.get('imageFilename', generate_image_filename_from_name(winner_data['name']))
        db_nft = NFT(name=winner_data['name'], image_filename=image_fn_winner, floor_price=winner_data['floorPrice'])
        db.add(db_nft)
        try:
            db.commit(); db.refresh(db_nft)
            logger.info(f"NFT '{winner_data['name']}' created on-the-fly during case open.")
        except Exception as e_create_nft:
            db.rollback() # Rollback NFT creation and balance changes
            user.ton_balance += case_cost_ton; user.total_won_ton -= winner_data['floorPrice']
            db.commit() # Commit the rollback of balance changes
            logger.error(f"Failed to create NFT '{winner_data['name']}' on-the-fly: {e_create_nft}")
            return jsonify({"error": "Internal prize data error, NFT creation failed"}), 500

    new_item = InventoryItem(
        user_id=user.id, nft_id=db_nft.id,
        current_value=db_nft.floor_price, # Initial value is floor price
        upgrade_multiplier=1.0 
    )
    db.add(new_item)
    db.commit()
    db.refresh(new_item) # Get the new_item.id
    
    return jsonify({
        "status": "success",
        "won_prize": { # Send back data for the frontend to display
            "id": new_item.id, # Crucial: ID of the new InventoryItem instance
            "name": db_nft.name, 
            "imageFilename": db_nft.image_filename,
            "floorPrice": db_nft.floor_price,
            "currentValue": new_item.current_value # Should be same as floorPrice initially
        },
        "new_balance_ton": user.ton_balance,
        # "new_balance_stars": user.star_balance,
    })

# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `upgrade_item_api` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
@app.route('/api/upgrade_item', methods=['POST'])
def upgrade_item_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Auth failed"}), 401
    user_id = auth_user_data["id"]

    data = flask_request.get_json()
    inventory_item_id = data.get('inventory_item_id')
    multiplier_str = data.get('multiplier_str') # Expecting string like "1.5", "2", etc.

    if not all([inventory_item_id, multiplier_str]):
        return jsonify({"error": "inventory_item_id and multiplier_str are required"}), 400
    
    try:
        multiplier = float(multiplier_str) 
        inventory_item_id = int(inventory_item_id)
    except ValueError:
        return jsonify({"error": "Invalid data format for multiplier or item_id"}), 400

    # Define upgrade chances on the backend to prevent client-side manipulation
    upgrade_chances_map = {1.5: 50, 2.0: 35, 3.0: 25, 5.0: 15, 10.0: 8, 20.0: 3} 
    if multiplier not in upgrade_chances_map:
        return jsonify({"error": f"Invalid multiplier: {multiplier}. Valid are {list(upgrade_chances_map.keys())}" }), 400
    
    success_chance = upgrade_chances_map[multiplier]

    db = next(get_db())
    item_to_upgrade = db.query(InventoryItem).filter(InventoryItem.id == inventory_item_id, InventoryItem.user_id == user_id).first()

    if not item_to_upgrade:
        return jsonify({"error": "Item not found in your inventory"}), 404

    if random.uniform(0, 100) < success_chance:
        # Upgrade success
        original_value = item_to_upgrade.current_value
        new_value = round(original_value * multiplier, 2) # Calculate new value
        value_increase = new_value - original_value # How much value was added
        
        item_to_upgrade.current_value = new_value
        item_to_upgrade.upgrade_multiplier *= multiplier # Track cumulative multiplier
        
        user = db.query(User).filter(User.id == user_id).first() # Re-fetch user for total_won_ton
        if user: user.total_won_ton += value_increase # Add only the increase in value
        
        db.commit()
        return jsonify({
            "status": "success", 
            "message": f"Upgrade successful! New value: {item_to_upgrade.current_value:.2f} TON",
            "item": { # Send back updated item details
                "id": item_to_upgrade.id, 
                "currentValue": item_to_upgrade.current_value, 
                "name": item_to_upgrade.nft.name, # Name doesn't change on upgrade unless you want it to
                "upgradeMultiplier": item_to_upgrade.upgrade_multiplier 
            }
        })
    else:
        # Upgrade failed - item is lost
        item_name_lost = item_to_upgrade.nft.name
        lost_value = item_to_upgrade.current_value # The value of the item that was lost
        
        user = db.query(User).filter(User.id == user_id).first() # Re-fetch user
        if user: user.total_won_ton -= lost_value # Subtract the lost value from total winnings
        
        db.delete(item_to_upgrade)
        db.commit()
        logger.info(f"Item {item_name_lost} (ID: {inventory_item_id}, Value: {lost_value}) from user {user_id} lost in upgrade.")
        return jsonify({
            "status": "failed", 
            "message": f"Upgrade failed! You lost {item_name_lost}.",
            "item_lost": True # Explicit flag for frontend
        })

# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `convert_to_ton_api` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
@app.route('/api/convert_to_ton', methods=['POST'])
def convert_to_ton_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Auth failed"}), 401
    user_id = auth_user_data["id"]

    data = flask_request.get_json()
    inventory_item_id = data.get('inventory_item_id')

    if not inventory_item_id: return jsonify({"error": "inventory_item_id is required"}), 400
    try: inventory_item_id = int(inventory_item_id)
    except ValueError: return jsonify({"error": "Invalid inventory_item_id"}), 400
    
    db = next(get_db())
    user = db.query(User).filter(User.id == user_id).first()
    item_to_convert = db.query(InventoryItem).filter(InventoryItem.id == inventory_item_id, InventoryItem.user_id == user_id).first()

    if not user: return jsonify({"error": "User not found"}), 404
    if not item_to_convert: return jsonify({"error": "Item not found in inventory"}), 404

    conversion_value = item_to_convert.current_value # Use current_value which reflects upgrades
    user.ton_balance += conversion_value
    # When converting, the item's value is realized, but it's not "won" again.
    # total_won_ton reflects value obtained from cases/upgrades. Selling/converting is just changing form.
    # However, if an upgrade increased its value, that increase was already added to total_won_ton.
    # So, no change to total_won_ton here.
    
    db.delete(item_to_convert)
    db.commit()

    return jsonify({
        "status": "success",
        "message": f"{item_to_convert.nft.name} converted to {conversion_value:.2f} TON.",
        "new_balance_ton": user.ton_balance
    })

# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `sell_all_items_api` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
@app.route('/api/sell_all_items', methods=['POST'])
def sell_all_items_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Auth failed"}), 401
    user_id = auth_user_data["id"]

    db = next(get_db())
    user = db.query(User).filter(User.id == user_id).first()
    if not user: return jsonify({"error": "User not found"}), 404

    if not user.inventory: # Check if inventory is empty
        return jsonify({"status": "no_items", "message": "Inventory is empty."})

    total_sell_value = sum(item.current_value for item in user.inventory)
    user.ton_balance += total_sell_value
    # Similar to convert_to_ton, selling all items realizes their current value.
    # The value (and increases from upgrades) was already accounted for in total_won_ton.
    # No change to total_won_ton here.
    
    # Delete all items from inventory for this user
    for item in user.inventory: # user.inventory will be a list here due to relationship
        db.delete(item)
    db.commit()

    return jsonify({
        "status": "success",
        "message": f"All items sold for {total_sell_value:.2f} TON.",
        "new_balance_ton": user.ton_balance
    })


# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `initiate_deposit_api`, `check_blockchain_for_deposit`, `verify_deposit_api` FUNCTIONS HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
@app.route('/api/initiate_deposit', methods=['POST'])
def initiate_deposit_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Authentication failed"}), 401
    user_id = auth_user_data["id"]

    data = flask_request.get_json()
    amount_str = data.get('amount')
    if amount_str is None: return jsonify({"error": "Amount is required"}), 400
    
    try:
        original_amount_ton = float(amount_str)
    except ValueError:
        return jsonify({"error": "Invalid amount format"}), 400
    
    if original_amount_ton <= 0: 
        return jsonify({"error": "Amount must be positive"}), 400
    if original_amount_ton > 10000: # Example max limit
        return jsonify({"error": "Maximum deposit amount exceeded"}), 400

    db = next(get_db())
    user = db.query(User).filter(User.id == user_id).first()
    if not user: return jsonify({"error": "User not found"}), 404

    # Generate a unique small addition to make the final amount somewhat unique for tracking
    unique_nano_part = random.randint(10000, 999999) # e.g., 0.00001 to 0.000999 TON
    original_amount_nano_ton = int(original_amount_ton * (10**9))
    final_amount_nano_ton_for_link_and_check = original_amount_nano_ton + unique_nano_part

    # Check for existing active pending deposit for this user
    existing_pending = db.query(PendingDeposit).filter(
        PendingDeposit.user_id == user_id,
        PendingDeposit.status == 'pending',
        PendingDeposit.expires_at > dt.now(timezone.utc)
    ).first()

    if existing_pending:
        time_left = existing_pending.expires_at - dt.now(timezone.utc)
        return jsonify({
            "error": "You already have an active deposit request.", # More specific error
            "message": f"Please complete your previous deposit or wait {int(time_left.total_seconds() / 60)} minutes for it to expire."
        }), 409 # HTTP 409 Conflict

    pending_deposit = PendingDeposit(
        user_id=user_id,
        original_amount_ton=original_amount_ton,
        unique_identifier_nano_ton=unique_nano_part, # Store the random part for reconciliation if needed
        final_amount_nano_ton=final_amount_nano_ton_for_link_and_check, # Store the exact nanoTON amount
        expected_comment=DEPOSIT_COMMENT, # Use the defined constant
        status='pending',
        expires_at=dt.now(timezone.utc) + timedelta(minutes=PENDING_DEPOSIT_EXPIRY_MINUTES)
    )
    db.add(pending_deposit)
    db.commit()
    db.refresh(pending_deposit)

    # For display on frontend, convert nanoTON back to TON string, preserving precision
    amount_to_send_str_display = f"{final_amount_nano_ton_for_link_and_check / (10**9):.9f}".rstrip('0').rstrip('.') 

    logger.info(f"Initiated deposit for user {user_id}: ID {pending_deposit.id}, AmountForLink {final_amount_nano_ton_for_link_and_check} nanoTON, Orig {original_amount_ton} TON, Comment: {DEPOSIT_COMMENT}")

    return jsonify({
        "status": "success",
        "pending_deposit_id": pending_deposit.id,
        "recipient_address": DEPOSIT_RECIPIENT_ADDRESS_RAW,
        "amount_to_send": amount_to_send_str_display, # For display if needed, but link uses nanoTON
        "final_amount_nano_ton": final_amount_nano_ton_for_link_and_check, # Crucial for ton:// link
        "comment": DEPOSIT_COMMENT, # URL encoded by frontend if necessary
        "expires_at": pending_deposit.expires_at.isoformat()
    })
async def check_blockchain_for_deposit(pending_deposit: PendingDeposit, db_session): # Pass db_session
    logger.info(f"Checking blockchain for pending deposit ID: {pending_deposit.id}, User: {pending_deposit.user_id}, Amount: {pending_deposit.final_amount_nano_ton} nanoTON, Comment: '{pending_deposit.expected_comment}'")
    
    provider = None # Initialize provider to None
    transaction_found_and_processed = False

    try:
        # Ensure LiteBalancer is configured correctly (e.g., from mainnet or testnet config)
        # For mainnet:
        provider = LiteBalancer.from_mainnet_config(trust_level=2) 
        # For testnet (if you are testing there):
        # provider = LiteBalancer.from_testnet_config(trust_level=2)
        
        await provider.start_up()
        logger.info(f"LiteBalancer started up successfully for deposit check {pending_deposit.id}")

        # Fetch recent transactions for the deposit recipient address
        # Adjust 'count' as needed; too low might miss tx, too high is less efficient.
        transactions = await provider.get_transactions(address=DEPOSIT_RECIPIENT_ADDRESS_RAW, count=30) 
        logger.info(f"Fetched {len(transactions)} transactions for address {DEPOSIT_RECIPIENT_ADDRESS_RAW}")

        for tx_data in transactions:
            # We are interested in incoming internal messages (transfers)
            if not tx_data.in_msg or not tx_data.in_msg.is_internal:
                continue

            tx_value_nano = tx_data.in_msg.info.value_coins # Value in nanoTON
            tx_comment_text = None
            tx_hash_hex = tx_data.cell.hash.hex() # Unique hash of the transaction

            # Optimization: Skip transactions older than the pending deposit creation time (with some buffer)
            if tx_data.now < int((pending_deposit.created_at - timedelta(minutes=5)).timestamp()):
                continue
            
            # Attempt to parse comment from the message body
            body_cell_slice = tx_data.in_msg.body.begin_parse()
            # Standard comment format: first 32 bits are op_code (0 for text comment)
            if body_cell_slice.remaining_bits >= 32: # Check if there are enough bits for op_code
                op_code = body_cell_slice.load_uint(32)
                if op_code == 0: # 0 indicates a text comment follows
                    try:
                        tx_comment_text = body_cell_slice.load_snake_string()
                    except Exception as e_parse_comment:
                        # Not all messages with op_code 0 will have a parsable string comment
                        logger.debug(f"Could not parse comment from transaction {tx_hash_hex} with op_code 0: {e_parse_comment}")
            else:
                logger.debug(f"Transaction {tx_hash_hex} body too short for op_code.")
            
            logger.debug(f"Scanning TX: hash={tx_hash_hex}, val={tx_value_nano}, cmt='{tx_comment_text}' (Expected val: {pending_deposit.final_amount_nano_ton}, cmt: '{pending_deposit.expected_comment}')")

            # Check for match: exact amount and exact comment
            if tx_value_nano == pending_deposit.final_amount_nano_ton and \
               tx_comment_text == pending_deposit.expected_comment:
                
                logger.info(f"MATCH FOUND for deposit ID {pending_deposit.id}! TX hash: {tx_hash_hex}")
                
                # It's crucial this runs within the original db_session context for commit
                user_to_credit = db_session.query(User).filter(User.id == pending_deposit.user_id).first()
                if not user_to_credit:
                    logger.error(f"Critical: User {pending_deposit.user_id} for pending deposit {pending_deposit.id} not found for crediting!")
                    pending_deposit.status = 'failed' # Mark as failed if user vanished
                    db_session.commit()
                    transaction_found_and_processed = True # Stop further checks
                    break # Exit loop, this deposit is resolved (as failed)

                user_to_credit.ton_balance += pending_deposit.original_amount_ton
                
                # Apply referral bonus if applicable
                if user_to_credit.referred_by_id:
                    referrer = db_session.query(User).filter(User.id == user_to_credit.referred_by_id).first()
                    if referrer:
                        referral_bonus = round(pending_deposit.original_amount_ton * 0.10, 2) # 10%
                        referrer.referral_earnings_pending += referral_bonus
                        logger.info(f"Referral bonus {referral_bonus:.2f} TON credited to referrer {referrer.id} from deposit by {user_to_credit.id}")

                pending_deposit.status = 'completed'
                db_session.commit()
                logger.info(f"Deposit ID {pending_deposit.id} completed for user {user_to_credit.id}. New balance: {user_to_credit.ton_balance:.2f}")
                transaction_found_and_processed = True
                return {"status": "success", "message": "Deposit confirmed and balance updated!", "new_balance_ton": user_to_credit.ton_balance}
        
        # If loop finishes and no transaction was found and processed
        if not transaction_found_and_processed:
            logger.info(f"No matching transaction found yet for deposit ID {pending_deposit.id}.")
            # Check for expiry after checking all recent transactions
            if pending_deposit.expires_at <= dt.now(timezone.utc):
                if pending_deposit.status == 'pending': # Ensure we only mark as expired once
                    pending_deposit.status = 'expired'
                    db_session.commit()
                logger.info(f"Deposit ID {pending_deposit.id} has expired.")
                return {"status": "expired", "message": "This deposit request has expired."}
            # If not expired and not found, it's still pending
            return {"status": "pending", "message": "Transaction not yet confirmed on the blockchain. Please wait a few minutes and try again."}

    except ConnectionRefusedError: # Specific error for LiteBalancer connection issues
        logger.error(f"LiteBalancer connection refused for deposit ID {pending_deposit.id}. Check network or LiteServer availability.")
        return {"status": "error", "message": "Cannot connect to TON network to verify. Please try again later."}
    except Exception as e:
        logger.error(f"Error during blockchain check for deposit ID {pending_deposit.id}: {type(e).__name__} - {e}", exc_info=True)
        # Generic error for other issues (pytoniq errors, etc.)
        return {"status": "error", "message": "An error occurred while checking for your transaction. Please try again later."}
    finally:
        if provider: 
            try:
                await provider.close_all()
                logger.info(f"LiteBalancer closed for deposit check {pending_deposit.id}")
            except Exception as close_e:
                logger.error(f"Error closing LiteBalancer for deposit check {pending_deposit.id}: {close_e}")
        else:
            logger.warning(f"LiteBalancer was not initialized for deposit check {pending_deposit.id}, no close needed.")
        logger.info(f"Blockchain check finished for deposit ID {pending_deposit.id}")
@app.route('/api/verify_deposit', methods=['POST'])
def verify_deposit_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Authentication failed"}), 401
    user_id = auth_user_data["id"]

    data = flask_request.get_json()
    pending_deposit_id = data.get('pending_deposit_id')

    if not pending_deposit_id:
        return jsonify({"error": "pending_deposit_id is required"}), 400
    
    db = next(get_db()) # Get a new session for this request
    pending_deposit = db.query(PendingDeposit).filter(
        PendingDeposit.id == pending_deposit_id,
        PendingDeposit.user_id == user_id # Ensure user owns this pending deposit
    ).first()

    if not pending_deposit:
        return jsonify({"error": "Pending deposit request not found or does not belong to you."}), 404

    # If already completed, just return success
    if pending_deposit.status == 'completed':
        user = db.query(User).filter(User.id == user_id).first() # Re-fetch user for current balance
        return jsonify({"status": "success", "message": "This deposit has already been confirmed.", "new_balance_ton": user.ton_balance if user else 0})
    
    # If expired, mark it if it was still pending and inform user
    if pending_deposit.status == 'expired' or pending_deposit.expires_at <= dt.now(timezone.utc):
        if pending_deposit.status == 'pending': # Mark as expired if checked after expiry time
            pending_deposit.status = 'expired'
            db.commit()
        return jsonify({"status": "expired", "message": "This deposit request has expired. Please initiate a new one."}), 400 # 400 or custom code
    
    # If still pending, run the blockchain check
    # This needs to run in an asyncio event loop
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        # Pass the current db session to the async function
        result = loop.run_until_complete(check_blockchain_for_deposit(pending_deposit, db))
    finally:
        loop.close()
    
    return jsonify(result) # Return the result from check_blockchain_for_deposit

# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `get_leaderboard_api` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
@app.route('/api/get_leaderboard', methods=['GET'])
def get_leaderboard_api():
    db = next(get_db())
    # Query users, order by total_won_ton in descending order, limit to top 100
    leaders_query = db.query(User).order_by(User.total_won_ton.desc()).limit(100).all()
    
    leaderboard_data = []
    for rank, user_leader in enumerate(leaders_query, 1):
        # Determine a display name: use first_name, then username, then a generic User_ID
        display_name = user_leader.first_name
        if not display_name and user_leader.username:
            display_name = user_leader.username
        if not display_name:
            display_name = f"User_{str(user_leader.id)[:6]}" # Truncated ID for brevity

        # Determine avatar character: first letter of display_name or 'U'
        avatar_char = (display_name[0] if display_name else "U").upper()

        leaderboard_data.append({
            "rank": rank,
            "name": display_name,
            "avatarChar": avatar_char,
            "income": user_leader.total_won_ton, # This is the score metric
            "user_id": user_leader.id # Include user_id if frontend needs to highlight current user
        })
    return jsonify(leaderboard_data)

# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `withdraw_referral_earnings_api` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
@app.route('/api/withdraw_referral_earnings', methods=['POST'])
def withdraw_referral_earnings_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Auth failed"}), 401
    user_id = auth_user_data["id"]

    db = next(get_db())
    user = db.query(User).filter(User.id == user_id).first()
    if not user: return jsonify({"error": "User not found"}), 404

    if user.referral_earnings_pending > 0:
        amount_withdrawn = user.referral_earnings_pending
        user.ton_balance += amount_withdrawn
        user.referral_earnings_pending = 0.0 # Reset pending earnings
        db.commit()
        return jsonify({
            "status": "success",
            "message": f"{amount_withdrawn:.2f} TON referral earnings withdrawn to main balance.",
            "new_balance_ton": user.ton_balance,
            "new_referral_earnings_pending": user.referral_earnings_pending
        })
    else:
        return jsonify({"status": "no_earnings", "message": "No referral earnings to withdraw."})


# Point 2: API Endpoint for Promocode Redemption
@app.route('/api/redeem_promocode', methods=['POST'])
def redeem_promocode_api():
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Authentication failed"}), 401
    user_id = auth_user_data["id"]

    data = flask_request.get_json()
    promocode_text = data.get('promocode_text', "").strip()

    if not promocode_text:
        return jsonify({"status": "error", "message": "Promocode cannot be empty."}), 400

    db = next(get_db())
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        return jsonify({"status": "error", "message": "User not found."}), 404

    promo_code_entry = db.query(PromoCode).filter(PromoCode.code_text == promocode_text).first()

    if not promo_code_entry:
        return jsonify({"status": "error", "message": "Invalid promocode."}), 404
    
    if promo_code_entry.activations_left <= 0:
        return jsonify({"status": "error", "message": "This promocode has no activations left."}), 400

    # Optional: Check if this user has already activated THIS specific code type.
    # This would require the UserPromoCodeActivation table.
    # existing_activation = db.query(UserPromoCodeActivation).filter(
    #     UserPromoCodeActivation.user_id == user_id,
    #     UserPromoCodeActivation.promo_code_id == promo_code_entry.id
    # ).first()
    # if existing_activation:
    #     return jsonify({"status": "error", "message": "You have already used this promocode."}), 400

    # Proceed with activation
    promo_code_entry.activations_left -= 1
    user.ton_balance += promo_code_entry.ton_amount
    
    # Optional: Record the activation
    # new_activation = UserPromoCodeActivation(user_id=user_id, promo_code_id=promo_code_entry.id)
    # db.add(new_activation)
    
    try:
        db.commit()
        logger.info(f"User {user_id} redeemed promocode '{promocode_text}'. Received {promo_code_entry.ton_amount} TON. Activations left: {promo_code_entry.activations_left}")
        return jsonify({
            "status": "success",
            "message": f"Promocode '{promocode_text}' redeemed! You received {promo_code_entry.ton_amount:.2f} TON.",
            "new_balance_ton": user.ton_balance
        })
    except SQLAlchemyError as e:
        db.rollback()
        logger.error(f"Database error redeeming promocode for user {user_id}: {e}")
        return jsonify({"status": "error", "message": "Database error. Please try again."}), 500


# Point 3: API Endpoint to finalize withdrawal (remove item from DB)
@app.route('/api/finalize_withdrawal/<int:inventory_item_id>', methods=['POST'])
def finalize_withdrawal_api(inventory_item_id):
    init_data_str = flask_request.headers.get('X-Telegram-Init-Data')
    auth_user_data = validate_init_data(init_data_str, BOT_TOKEN)
    if not auth_user_data: return jsonify({"error": "Authentication failed"}), 401
    user_id = auth_user_data["id"]

    db = next(get_db())
    item_to_remove = db.query(InventoryItem).filter(
        InventoryItem.id == inventory_item_id,
        InventoryItem.user_id == user_id
    ).first()

    if not item_to_remove:
        return jsonify({"status": "error", "message": "Item not found in your inventory or already withdrawn."}), 404

    item_name = item_to_remove.nft.name
    item_value = item_to_remove.current_value

    # Before deleting, adjust total_won_ton if the withdrawal implies "losing" its value from the game's economy perspective.
    # If withdrawal means the item is out of the game, its value should be subtracted from total_won_ton.
    user = db.query(User).filter(User.id == user_id).first()
    if user:
        user.total_won_ton -= item_value 
        # Ensure total_won_ton doesn't go negative if something is off
        user.total_won_ton = max(0, user.total_won_ton) 
    
    db.delete(item_to_remove)
    
    try:
        db.commit()
        logger.info(f"User {user_id} finalized withdrawal of item ID {inventory_item_id} ('{item_name}', value: {item_value}). Item removed from DB. Total won adjusted.")
        return jsonify({"status": "success", "message": f"Withdrawal of '{item_name}' confirmed."})
    except SQLAlchemyError as e:
        db.rollback()
        # If rollback, revert total_won_ton adjustment if it was made
        if user: user.total_won_ton += item_value 
        # Don't commit here, just log the state
        logger.error(f"Database error finalizing withdrawal for item {inventory_item_id}, user {user_id}: {e}")
        return jsonify({"status": "error", "message": "Database error during withdrawal finalization."}), 500


# --- ÐšÐ¾Ð¼Ð°Ð½Ð´Ñ‹ Ð±Ð¾Ñ‚Ð° ---
@bot.message_handler(commands=['start'])
def send_welcome(message):
    logger.info(f"ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° /start Ð¾Ñ‚ chat_id: {message.chat.id} ({message.from_user.username or 'N/A'})")
    db = next(get_db())
    user = db.query(User).filter(User.id == message.chat.id).first()
    created_now = False
    if not user:
        created_now = True
        user = User(
            id=message.chat.id, 
            username=message.from_user.username,
            first_name=message.from_user.first_name,
            last_name=message.from_user.last_name,
            ton_balance=0.0, 
            star_balance=0,
            referral_code=f"ref_{message.chat.id}_{random.randint(1000,9999)}" # Generate a unique referral code
        )
        db.add(user) 
    
    try:
        start_param = message.text.split(' ')
        if len(start_param) > 1 and start_param[1].startswith('ref_'):
            referrer_code_param = start_param[1]
            # Apply referral only if the user is being created now AND doesn't already have a referrer
            if created_now and not user.referred_by_id: 
                referrer = db.query(User).filter(User.referral_code == referrer_code_param).first()
                if referrer and referrer.id != user.id : # Cannot refer self
                    user.referred_by_id = referrer.id
                    logger.info(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {user.id} Ð¿Ñ€Ð¸ÑˆÐµÐ» Ð¿Ð¾ Ñ€ÐµÑ„. ÐºÐ¾Ð´Ñƒ {referrer_code_param} Ð¾Ñ‚ {referrer.id}")
                    # Optionally, send a notification to the referrer
                    try:
                        bot.send_message(referrer.id, f"ðŸŽ‰ Ð’Ð°Ñˆ Ð´Ñ€ÑƒÐ³ {user.first_name or user.username or user.id} Ð¿Ñ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸Ð»ÑÑ Ð¿Ð¾ Ð²Ð°ÑˆÐµÐ¹ ÑÑÑ‹Ð»ÐºÐµ!")
                    except Exception as e_notify:
                        logger.warning(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð¸Ñ‚ÑŒ Ñ€ÐµÑ„ÐµÑ€ÐµÑ€Ð° {referrer.id}: {e_notify}")
    except Exception as e:
        logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ñ€ÐµÑ„ÐµÑ€Ð°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð° Ð´Ð»Ñ {user.id}: {e}")

    # Update user details if they changed in Telegram profile
    changed_in_db = False
    if user.username != message.from_user.username: user.username = message.from_user.username; changed_in_db=True
    if user.first_name != message.from_user.first_name: user.first_name = message.from_user.first_name; changed_in_db=True
    if user.last_name != message.from_user.last_name: user.last_name = message.from_user.last_name; changed_in_db=True
    
    if created_now or changed_in_db:
        try:
            db.commit()
            if created_now: logger.info(f"ÐÐ¾Ð²Ñ‹Ð¹ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {message.chat.id} ({message.from_user.username or 'N/A'}) Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½/Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½ Ð² Ð‘Ð”.")
            elif changed_in_db: logger.info(f"Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {message.chat.id} Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹.")
        except IntegrityError: # Could happen if referral code was not unique by cosmic chance
            db.rollback()
            logger.error(f"IntegrityError Ð¿Ñ€Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {message.chat.id}. Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾, Ð´ÑƒÐ±Ð»Ð¸Ñ€ÑƒÑŽÑ‰Ð¸Ð¹ÑÑ referral_code.")
            # Try to regenerate referral code if it was the issue
            if created_now and user.referral_code.startswith(f"ref_{message.chat.id}_"):
                user.referral_code = f"ref_{message.chat.id}_{random.randint(10000,99999)}" # Wider range
                try:
                    db.add(user); db.commit()
                    logger.info(f"Referral code regenerated for user {message.chat.id}")
                except Exception as e_retry:
                    db.rollback()
                    logger.error(f"Failed to save user {message.chat.id} even after regenerating referral code: {e_retry}")
        except Exception as e_commit:
            db.rollback()
            logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {message.chat.id}: {e_commit}")

    markup = types.InlineKeyboardMarkup()
    if not MINI_APP_URL:
        logger.error("MINI_APP_URL Ð½Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½!")
        bot.send_message(message.chat.id, "ÐžÑˆÐ¸Ð±ÐºÐ° ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸: Mini App URL Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½.")
        return
    
    try:
        web_app_info = types.WebAppInfo(url=MINI_APP_URL) 
        app_button = types.InlineKeyboardButton(text="ðŸŽ® ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Pusik Gifts", web_app=web_app_info)
        markup.add(app_button)
        bot.send_message(
            message.chat.id,
            "Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ Ð² Pusik Gifts! ðŸŽ\n\n"
            "ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ñ€ÑƒÐ»ÐµÑ‚ÐºÑƒ Ð¸ Ð¸ÑÐ¿Ñ‹Ñ‚Ð°Ñ‚ÑŒ ÑÐ²Ð¾ÑŽ ÑƒÐ´Ð°Ñ‡Ñƒ!",
            reply_markup=markup
        )
    except Exception as e: 
        logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐµ /start ({message.chat.id}): {type(e).__name__} - {e}")
        try:
             bot.send_message(message.chat.id, "ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ð¸ Ð¸Ð³Ñ€Ñ‹. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.")
        except Exception as e2:
            logger.error(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŽ {message.chat.id}: {e2}")

@bot.message_handler(func=lambda message: True)
def echo_all(message):
    logger.info(f"ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ {message.chat.id}: {message.text}")
    bot.reply_to(message, "ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ /start, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Pusik Gifts.")

# --- Polling ---
# ðŸ”´ðŸ”´ðŸ”´ PASTE YOUR `run_bot_polling` FUNCTION HERE (UNCHANGED) ðŸ”´ðŸ”´ðŸ”´
bot_polling_started = False
bot_polling_thread = None
def run_bot_polling():
    global bot_polling_started
    if bot_polling_started: 
        logger.info("Polling ÑƒÐ¶Ðµ Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½.")
        return
    
    bot_polling_started = True
    logger.info("Ð—Ð°Ð¿ÑƒÑÐº Ð±Ð¾Ñ‚Ð° Ð² Ñ€ÐµÐ¶Ð¸Ð¼Ðµ polling...")
    
    max_retries_remove_webhook = 3
    for i in range(max_retries_remove_webhook):
        try:
            bot.remove_webhook()
            logger.info("Ð’ÐµÐ±Ñ…ÑƒÐº ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ ÑƒÐ´Ð°Ð»ÐµÐ½ (ÐµÑÐ»Ð¸ Ð±Ñ‹Ð»).")
            break # Success
        except Exception as e:
            logger.warning(f"ÐŸÐ¾Ð¿Ñ‹Ñ‚ÐºÐ° {i+1}/{max_retries_remove_webhook} ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²ÐµÐ±Ñ…ÑƒÐº Ð½Ðµ ÑƒÐ´Ð°Ð»Ð°ÑÑŒ: {e}")
            if i < max_retries_remove_webhook - 1:
                time.sleep(2) # Wait before retrying
            else:
                logger.error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²ÐµÐ±Ñ…ÑƒÐº Ð¿Ð¾ÑÐ»Ðµ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ñ… Ð¿Ð¾Ð¿Ñ‹Ñ‚Ð¾Ðº. Polling Ð¼Ð¾Ð¶ÐµÑ‚ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ ÐµÑÐ»Ð¸ Ð²ÐµÐ±Ñ…ÑƒÐº Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½.")
    
    while True: # Outer loop for restarting infinity_polling if it crashes badly
        if not bot_polling_started: # Check flag in case polling was stopped externally
            logger.info("Polling Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½.")
            break
        try:
            logger.info("Ð¡Ñ‚Ð°Ñ€Ñ‚ infinity_polling...")
            bot.infinity_polling(logger_level=logging.INFO, skip_pending=True, timeout=60, long_polling_timeout=30)
            # If infinity_polling exits cleanly (e.g., stop_polling called), it won't raise an exception
            logger.info("infinity_polling Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð»ÑÑ Ð±ÐµÐ· Ð¾ÑˆÐ¸Ð±Ð¾Ðº.")
            # Depending on desired behavior, you might want to break here or continue to restart
            # For robustness, let's assume we want it to keep running unless explicitly stopped.
        except telebot.apihelper.ApiTelegramException as e:
            logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° API Telegram Ð² polling: {e}. ÐšÐ¾Ð´: {e.error_code}")
            if e.error_code == 401: # Unauthorized
                logger.error("ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ‚Ð¾ÐºÐµÐ½ Ð±Ð¾Ñ‚Ð°. Polling Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½.")
                bot_polling_started = False # Stop trying
                break 
            elif e.error_code == 409: # Conflict (e.g., webhook set elsewhere)
                logger.error("ÐšÐ¾Ð½Ñ„Ð»Ð¸ÐºÑ‚ (Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾, Ð´Ñ€ÑƒÐ³Ð¾Ð¹ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€ Ð±Ð¾Ñ‚Ð° Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½ Ð¸Ð»Ð¸ Ð²ÐµÐ±Ñ…ÑƒÐº ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½). Polling Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½.")
                bot_polling_started = False # Stop trying
                break
            else:
                logger.error(f"Ð”Ñ€ÑƒÐ³Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° API Telegram, Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÐº polling Ñ‡ÐµÑ€ÐµÐ· 30 ÑÐµÐºÑƒÐ½Ð´...")
                time.sleep(30)
        except ConnectionError as e: # Includes requests.exceptions.ConnectionError
            logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ: {e}. ÐŸÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÐº polling Ñ‡ÐµÑ€ÐµÐ· 60 ÑÐµÐºÑƒÐ½Ð´...")
            time.sleep(60)
        except Exception as e: # Catch-all for other unexpected errors
            logger.error(f"ÐšÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð² polling: {type(e).__name__} - {e}. ÐŸÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÐº polling Ñ‡ÐµÑ€ÐµÐ· 60 ÑÐµÐºÑƒÐ½Ð´...", exc_info=True)
            time.sleep(60)
        else: # If infinity_polling finishes without exception (e.g. by bot.stop_polling())
            logger.warning("infinity_polling Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð»ÑÑ ÑˆÑ‚Ð°Ñ‚Ð½Ð¾. Ð•ÑÐ»Ð¸ ÑÑ‚Ð¾ Ð½Ðµ Ð¾Ð¶Ð¸Ð´Ð°Ð»Ð¾ÑÑŒ, Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ. ÐŸÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÐº Ñ‡ÐµÑ€ÐµÐ· 15 ÑÐµÐºÑƒÐ½Ð´...")
            time.sleep(15) # Wait a bit before restarting, in case it was a manual stop
        
        if not bot_polling_started: # Double check before looping again
            logger.info("Polling Ð¾ÐºÐ¾Ð½Ñ‡Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð¿ÐµÑ€ÐµÐ´ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ð¼ Ñ†Ð¸ÐºÐ»Ð¾Ð¼.")
            break


if __name__ == '__main__':
    if BOT_TOKEN and not bot_polling_started and os.environ.get("WERKZEUG_RUN_MAIN") != "true":
        logger.info("ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ð¿Ñ€Ð¾Ñ†ÐµÑÑ, Ð·Ð°Ð¿ÑƒÑÐº Ð¿Ð¾Ñ‚Ð¾ÐºÐ° Ð´Ð»Ñ polling Ð±Ð¾Ñ‚Ð°.")
        bot_polling_thread = threading.Thread(target=run_bot_polling)
        bot_polling_thread.daemon = True # Allow main thread to exit even if polling thread is running
        bot_polling_thread.start()
    elif os.environ.get("WERKZEUG_RUN_MAIN") == "true":
        # This is the reloader process from Werkzeug, do not start polling here
        logger.info("ÐŸÑ€Ð¾Ñ†ÐµÑÑ Werkzeug reloader, polling Ð±Ð¾Ñ‚Ð° Ð½Ðµ Ð·Ð°Ð¿ÑƒÑÐºÐ°ÐµÑ‚ÑÑ Ð·Ð´ÐµÑÑŒ.")
    
    logger.info("Ð—Ð°Ð¿ÑƒÑÐº Flask development server...")
    # use_reloader=False if you face issues with multiple polling threads in dev. For prod, this is fine.
    # Debug=False for production.
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)), debug=False, use_reloader=True)

```
